import pygame as py
import sys
import random
import json
import perks as pk
CONFIG_FILE = "config.json"

# Storable Data
toggle_music = True
toggle_sfx = True
toggle_fireworks = False
toggle_brightness = False
toggle_fps = False
toggle_visible_collision = False
toggle_display_speed = False
toggle_dark_mode = True
p1_skin = 'Yellow'
p2_skin = 'Green'
language = 'T. Việt'
current_p1_perk_idx = 0
current_p2_perk_idx = 0

py.init()
state = 'MENU'
difficulty = 'MEDIUM'

# SCREEN SETUP
screen = py.display.set_mode((900, 680))
GAME_ICON = py.image.load('Resources/Yellow.png')
py.display.set_caption('Dragon Boat Race')
py.display.set_icon(GAME_ICON)

# CONSTANTS
BACKGROUND = py.image.load('Resources/HoTay.jpg').convert_alpha()
BARRIER = py.image.load('Resources/Phao.png').convert_alpha()
WAVE = py.image.load('Resources/water.png').convert_alpha()
ROCK_IMG = py.transform.scale(py.image.load('Resources/rocks.svg'), (60, 30))
YELLOW_SHIP_G = py.transform.scale(GAME_ICON, (120, 50))
GREEN_SHIP_G = py.transform.scale(py.image.load('Resources/Green.png'), (120, 50))
ENERGY_BALL = py.transform.scale(py.image.load('Resources/NangLuong.png'), (40, 40))
FIREWORK_IMG = py.image.load('Resources/firework_combined.png')
PROGRESS_BAR = py.transform.scale(py.image.load('Resources/bar.png'), (400, 50))
YELLOW_BALL = py.transform.scale(py.image.load('Resources/yellow_ball.png'), (25, 25))
GREEN_BALL = py.transform.scale(py.image.load('Resources/green_ball.png'), (25, 25))

# SUB SETTINGS RESOURCES
TRASH_BIN = py.transform.scale(py.image.load('Resources/trashbin.png'), (50, 50))
triangle = py.image.load('Resources/triangle.png')
triangle2 = triangle.copy()
triangle3 = triangle.copy()
triangle4 = triangle.copy()
WINNER_FONT = py.font.SysFont('Forte', 80, False)

# SETTING RESOURCES
REPLAY_VI = py.transform.scale(py.image.load('Resources/Setting/play_again.png'), (230, 100)).convert_alpha()
REPLAY_EN = py.transform.scale(py.image.load('Resources/Setting/play_again_en.png'), (230, 100)).convert_alpha()
PLAY_VI = py.transform.scale(py.image.load('Resources/Setting/play.png'), (230, 100)).convert_alpha()
PLAY_EN = py.transform.scale(py.image.load('Resources/Setting/play_en.png'), (230, 100)).convert_alpha()
SETTING_VI = py.transform.scale(py.image.load('Resources/Setting/set_vi.png'), (230, 100)).convert_alpha()
SETTING_EN = py.transform.scale(py.image.load('Resources/Setting/set_en.png'), (230, 100)).convert_alpha()
SETTING_MENU_VI = py.image.load('Resources/Setting/bg_set_vn_no_bg.png').convert_alpha()
SETTING_MENU_EN = py.image.load('Resources/Setting/bg_set_en_no_bg.png').convert_alpha()
MENU_BG_VI = py.image.load('Resources/bg1_vn_no_bg.png')
MENU_BG_EN = py.image.load('Resources/bg1_en_no_bg.png').convert_alpha()
CLOSE = py.transform.scale(py.image.load('Resources/Setting/close.png'), (100, 100))
toggle_ON_VI = py.transform.scale(py.image.load('Resources/Setting/on_vn.png'), (175, 75))
toggle_OFF_VI = py.transform.scale(py.image.load('Resources/Setting/off_vn.png'), (175, 75))
toggle_ON_EN = py.transform.scale(py.image.load('Resources/Setting/on_en.png'), (175, 75))
toggle_OFF_EN = py.transform.scale(py.image.load('Resources/Setting/off_en.png'), (175, 75))

# PLAYER SETTINGS:
YELLOW_SHIP = py.transform.scale(py.image.load('Resources/Yellow.png'), (200, 80))
GREEN_SHIP = py.transform.scale(py.image.load('Resources/Green.png'), (200, 80))

# BOUNDING BOX
PLAY_BOX = py.Rect(220, 405, 170, 50)
SETTING_BOX = py.Rect(520, 405, 170, 50)
REPLAY_BOX = py.Rect(350, 350, 170, 50)
CLOSE_BOX = py.Rect(850, 0, 50, 55)
TRASH_BOX = py.Rect(600, 400, 50, 50)
triangle_BOX = py.Rect(350, 170, 50, 40)
triangle_BOX2 = py.Rect(350, 520, 50, 40)
triangle_BOX3 = py.Rect(800, 100, 50, 40)
triangle_BOX4 = py.Rect(800, 450, 50, 40)

# SOUNDS
BG_music = py.mixer.Sound('Resources/nhacnen.mp3')
GAME_music = py.mixer.Sound('Resources/nhacnen1.mp3')
ENERGY_BALL_SOUND = py.mixer.Sound('Resources/power_sound.wav')
ROCK_SOUND = py.mixer.Sound('Resources/rock_sound.wav')
CLICK_sfx = py.mixer.Sound('Resources/ButtonPlate Click.wav')
WIN_sfx = py.mixer.Sound('Resources/WinSFX.mp3')
BG_music.play(-1)

# Finish line
FINISH_LINE = py.transform.scale(py.image.load('Resources/finish_line.png'), (200, 265))

# Surfaces
TS_SURFACE = py.Surface((900, 680)).convert_alpha()
triangle_SURFACE = py.Surface((50, 45)).convert_alpha()
triangle_SURFACE2 = triangle_SURFACE.copy()
triangle_SURFACE3 = triangle_SURFACE.copy()
triangle_SURFACE4 = triangle_SURFACE.copy()
triangle_SURFACE.set_alpha(0)
triangle_SURFACE2.set_alpha(0)
triangle_SURFACE3.set_alpha(0)
triangle_SURFACE4.set_alpha(0)
TS_SURFACE.set_alpha(0)
BRIGHTNESS_SURFACE = py.Surface((900, 680)).convert()
BRIGHTNESS_SURFACE.fill((0, 0, 0))

# WINNER_FONT TEXT
winner_text = None
# TRANSPARENCY/HOVERING EFFECT
play_transparency = 255
setting_transparency = 255
replay_transparency = 255
close_transparency = 255
delete_saved_transparency = 255
triangle_transparency = triangle2_transparency = triangle3_transparency = triangle4_transparency = 255

# POSITION
energy_player1 = energy_player2 = 0
x_bg = 0
y_player1 = 250
y_player2 = 500
x_wave1 = x_wave2 = 0
speed_for_player1 = speed_for_player2 = 5
normal_speed_for_player1 = normal_speed_for_player2 = 5
rocks = []
fireworks = []
player1_ball_x = player2_ball_x = 250

# ENERGY BALL'S CONFIGURATION
x_energy_ball1 = x_energy_ball2 = 900
y_energy_ball1 = random.randint(130, 350)
y_energy_ball2 = random.randint(430, 620)
energy_ball1_is_visible = True
energy_ball2_is_visible = True
energy_ball_timer1 = 0
energy_ball_timer2 = 0
energy_ball_respawn_time = 10 * 1000

# DISTANCE TRACKING
distance_to_finish_line1 = 0
distance_to_finish_line2 = 0
finish_line_base_x = 40000

# PERKS
backend_perks = pk.get_perks('ENGLISH')

# Special Perks for P1
absorption_pack = pk.get_manual_use_ability('Absorption')
timestop_pack = pk.get_manual_use_ability('Timestop')
flashstep_pack = pk.get_manual_use_ability('Flash Step')
# Flash Step
flashstepping = False
last_flashstep = -99999
flashstep_start = 0
# Timestop
timestopping = False
last_ts = -9999
ts_start = 0
# Dark Magic
last_create_rocks = -9999
create_rocks_start = 0
ability_counts = 0
# Special Perks for P2
absorption_pack2 = pk.get_manual_use_ability('Absorption')
timestop_pack2 = pk.get_manual_use_ability('Timestop')
flashstep_pack2 = pk.get_manual_use_ability('Flash Step')
# Flash Step
flashstepping2 = False
last_flashstep2 = -99999
flashstep_start2 = -9999
# Timestop
timestopping2 = False
last_ts2 = 0
ts_start2 = 0
# Dark Magic
last_create_rocks2 = -9999
create_rocks_start2 = 0
ability_counts2 = 0

# List of Colors
bg_color = (0, 166, 82)
colors = [
    bg_color,  # [0] Default Green
    (51, 255, 51),  # [1] Green
    (51, 255, 255),  # [2] Sky blue
    (255, 0, 0),  # [3] Red
    (255, 255, 0),  # [4] Yellow
    (255, 128, 0),  # [5] Orange
    (255, 255, 255),  # [6] White
    (0, 0, 0),  # [7] Black
    (102, 255, 102),  # [8] Light Green
    (153, 0, 153),  # [9] Purple
    (30, 30, 30),  # [10] Dark
]
rgb_colors = [
    (51, 255, 51),  # Green
    (255, 255, 0),  # Yellow
    (255, 128, 0),  # Orange
    (255, 0, 0),  # Red
    (153, 0, 153),  # Purple
    (51, 255, 255),  # Sky blue
]

# List of buttons
buttons = [
    py.Rect(0, 0, 300, 50),  # ADVANCED SETTTINGS [0]
    py.Rect(0, 200, 100, 100),  # Background [1]
    py.Rect(300, 500, 300, 50),  # Save Changes [2]
    py.Rect(0, 400, 100, 100),  # Player's Configuration [3]
    py.Rect(450, 0, 10, 900),  # Vertical Line [4]
    py.Rect(0, 340, 900, 10),  # Horizontal Line [5]
    py.Rect(460, 100, 440, 50),  # Current Perk's Back Layer [6]
    py.Rect(460, 450, 440, 50),  # Current Perk2's Back Layer [7]
    py.Rect(585, 150, 200, 100),  # Perk's Description [8]
    py.Rect(585, 500, 200, 100),  # Perk2's Description [9]
    py.Rect(460, 50, 440, 50),  # Perk Rect [10]
    py.Rect(460, 400, 440, 50),  # Perk2 Rect [11]
    py.Rect(350, 450, 170, 50),  # Setting button in End State [12]
    py.Rect(0, 50, 450, 100),
    py.Rect(0, 400, 450, 100)
]
# buttons


class Slider:
    def __init__(self, x, y, w, h, value=0.5, min_val=0, max_val=1, knob_radius=14, offset=90, integer=False):
        self.x = x
        self.y = y
        self.w = w
        self.h = h
        self.offset = offset
        self.value = value
        self.min_val = min_val
        self.max_val = max_val
        self.knob_radius = knob_radius
        self.dragging = False
        self.integer = integer

    def handle_event(self, event):
        if event.type == py.MOUSEBUTTONDOWN and event.button == 1:
            mouse_x, mouse_y = event.pos
            knob_x = self.x + (self.value - self.min_val) / (
                    self.max_val - self.min_val) * self.w  # Tính vị trí x nút trượt
            if (mouse_x - knob_x) ** 2 + (
                    mouse_y - self.y) ** 2 <= self.knob_radius ** 2:  # Dùng công thức tính tọa độ của chuột có nằm trong bán kính của knob không
                self.dragging = True
            elif self.x <= mouse_x <= self.x + self.w and (self.y - self.h // 2) <= mouse_y <= (
                    self.y + self.h // 2):  # Khi bấm chuột trong thanh truợt
                self.value = (mouse_x - self.x) / self.w * (
                        self.max_val - self.min_val) + self.min_val  # Tính giá trị từ vị trí chuột
                self.value = max(self.min_val, min(self.max_val,
                                                   self.value))  # Giới hạn lại giá trị để đảm bảo không bé hơn min_val và không lớn hơn max_val (Clamp)
                self.dragging = True

        elif event.type == py.MOUSEBUTTONUP and event.button == 1:
            self.dragging = False  # Ngừng kéo knob

        elif event.type == py.MOUSEMOTION and self.dragging:  # Xử lí khi kéo knob
            mouse_x, _ = event.pos  # Lấy x của chuột
            mouse_x = max(self.x, min(self.x + self.w, mouse_x))  # Giới hạn mouse_x để knob không bị trượt ra ngoài
            self.value = (mouse_x - self.x) / self.w * (
                    self.max_val - self.min_val) + self.min_val  # Tính giá trị từ vị trí của chuột y như ở trên
            self.value = max(self.min_val, min(self.max_val, self.value))  # Clamp

    def draw(self, surface, font, label, dark_mode=False):
        track_rect = py.Rect(self.x, self.y - self.h // 2, self.w, self.h)
        py.draw.rect(surface, (180, 180, 180), track_rect, border_radius=10)
        ratio = (self.value - self.min_val) / (self.max_val - self.min_val)
        fill_width = self.w * ratio
        fill_rect = py.Rect(self.x, self.y - self.h // 2, fill_width, self.h)
        py.draw.rect(surface, (50, 120, 255), fill_rect, border_radius=10)
        knob_x = self.x + ratio * self.w
        knob_color = (100, 150, 255) if self.dragging else (50, 120, 255)
        py.draw.circle(surface, knob_color, (int(knob_x), self.y), self.knob_radius)
        display_percent = int(ratio * 100)
        if not self.integer:  # Cho thêm 1 lựa chọn là sử dụng % hay giá trị thô
            text_surface = font.render(f"{label}: {display_percent}%", True,
                                       (255, 255, 255) if dark_mode else (0, 0, 0))
        else:
            text_surface = font.render(f"{label}: {int(self.value)}", True, (255, 255, 255) if dark_mode else (0, 0, 0))
        text_rect = text_surface.get_rect()
        text_rect.centerx = self.x + self.w / 2
        text_rect.y = self.y + self.offset
        surface.blit(text_surface, text_rect)


class InputBox:
    def __init__(self, x, y, w, h, text='', min_val=0, max_val=100, multiplier=1.0, num_val=True, lost_focus=False):
        self.rect = py.Rect(x, y, w, h)
        self.color_inactive = (100, 100, 100)
        self.color_active = (0, 0, 255)
        self.BG_COLOR = self.color_inactive
        self.text = text
        self.font = py.font.SysFont('Arial', 25)
        self.active = False
        self.min_val = min_val
        self.max_val = max_val
        self.multiplier = multiplier
        self.num_val = num_val
        self.lost_focus = lost_focus

    def _sync_live(self, slider):
        if not self.num_val:
            return  # Nếu là chế độ text (num_val=False) thì không cần đồng bộ slider
        if self.text == '':  # Nếu không có gì trong input
            if slider:  # Nếu đang kéo slider
                slider.value = (self.min_val / self.max_val) * self.multiplier  # Đồng bộ hóa giá trị của slider
            return  # Trả về kết quả và ngừng xử lí
        try:
            val = int(self.text)  # Thử đặt giá trị thành số nguyên của string được hiện trên màn hình
        except ValueError:
            return  # Ngừng xử lí nếu giá trị quá lớn hoặc không đúng loại giá trị
        val = max(self.min_val, min(self.max_val, val))  # Clamp
        if slider:
            slider.value = (val / self.max_val) * self.multiplier

    def handle_event(self, event, slider=None):
        if event.type == py.MOUSEBUTTONDOWN and event.button == 1:
            self.active = self.rect.collidepoint(
                event.pos)  # Đặt giá trị của InputBox là True hoặc False, tùy thuộc nếu nhấn chuột có nhấn vào InputBox hay không
            if self.active and self.lost_focus:
                self.text = ''
            self.BG_COLOR = self.color_active if self.active else self.color_inactive  # Chỉnh sửa màu viền của InputBox tùy vào trạng thái
        if not self.active:  # Nếu không được chọn thì thoát hàm có chủ đích. (Nếu self.active ở trên là True thì sẽ không thỏa mãn điều kiện, dẫn đến tiếp tục xử lí.)
            return
        if event.type == py.KEYDOWN:
            if event.key == py.K_BACKSPACE:  # Xóa
                self.text = self.text[:-1]
                if self.num_val:
                    self._sync_live(slider)  # Đồng bộ hóa với slider
                return
            if event.key == py.K_DELETE:  # Xóa toàn bộ
                self.text = ''
                if self.num_val:
                    self._sync_live(slider)
                return
            if event.key == py.K_RETURN:  # Enter
                self.active = False
                self.BG_COLOR = self.color_inactive
                return

            # Xử lí nhập liệu phụ thuộc vào num_val
            if self.num_val:  # ----> Nếu num_val=True thì chỉ cho nhập số
                if event.unicode and event.unicode.isdigit():  # Xử lí xem đầu vào có phải là chữ số không
                    if len(self.text) < len(
                            str(self.max_val)):  # Nếu độ dài giá trị bên trong vẫn chưa bằng giá trị tối đa
                        self.text += event.unicode  # Thêm kí tự
                        try:
                            if int(self.text) > self.max_val:  # Nếu lớn hơn giá trị tối đa
                                self.text = str(self.max_val)  # Đặt về giá trị tối đa
                        except ValueError:  # Nếu giá trị quá lớn thì bỏ qua
                            pass
                        self._sync_live(slider)  # Sync
            else:  # Cho nhập bất kì kí tự nào
                if event.unicode:
                    if len(self.text) < 16:
                        self.text += event.unicode  # Không giới hạn, thêm bất kỳ kí tự nào người dùng nhập

    def draw(self, surface):
        py.draw.rect(surface, (255, 255, 255), self.rect, border_radius=8)
        py.draw.rect(surface, self.BG_COLOR, self.rect, 2, border_radius=8)
        txt_surface = self.font.render(
            self.text if self.text != '' else (str(self.min_val) if self.num_val else ''),
            # Nếu là số thì hiển thị min_val mặc định, còn text thì để trống
            True, (0, 0, 0))
        text_rect = txt_surface.get_rect(center=self.rect.center)
        surface.blit(txt_surface, text_rect)


class Dropdown:
    def __init__(self, x, y, w, h, options, default_value, font, max_visible_items=5, extension=True):
        self.rect = py.Rect(x, y, w, h)
        self.options = options
        self.max_visible_items = max_visible_items  # Maximum number of visible items
        self.scroll_offset = 0  # Current scroll position (in items)
        if isinstance(default_value, str):
            if default_value in self.options:
                self.selected_index = self.options.index(
                    default_value)  # Nếu lựa chọn mặc định đã có sẵn trong ds thì lấy index
            else:
                self.selected_index = 0  # Nếu ko thì lấy gtr đầu tiên
        else:
            if 0 <= default_value < len(self.options):
                self.selected_index = default_value  # Nếu list đủ dài để lấy giá trị mặc định là số nguyên thì lấy luôn
            else:
                self.selected_index = 0  # Không thì lấy gtr đầu tiên như ở trên  <<Cách xử lí này còn gọi là Fallback>>

        self.is_open = False
        self.font = font
        self.hover_index = -1
        self.extension = extension

    def handle_event(self, event):
        if event.type == py.MOUSEBUTTONDOWN and event.button == 1:  # Nếu nhấn chuột trái
            mouse_pos = event.pos  # Lấy tọa độ chuột
            if self.rect.collidepoint(mouse_pos):  # Nếu bấm vào dropdown
                play_sfx()
                self.is_open = not self.is_open
            elif self.is_open:  # Nếu đang mở thì:
                # Chỉ kiểm tra trong vùng hiển thị (scroll_offset → scroll_offset + max_visible_items)
                for i in range(self.scroll_offset, min(self.scroll_offset + self.max_visible_items, len(self.options))):
                    option_rect = py.Rect(
                        self.rect.x,
                        self.rect.y + (i - self.scroll_offset + 1) * self.rect.h,
                        self.rect.w,
                        self.rect.h
                    )
                    if option_rect.collidepoint(mouse_pos):  # Nếu bấm vào 1 lựa chọn
                        play_sfx()
                        self.selected_index = i  # Đặt index thành i (i là index của lựa chọn được chọn)
                        self.is_open = False  # Đóng dropdown
                        break
                else:
                    self.is_open = False  # Nếu click ngoài thì đóng

        elif event.type == py.MOUSEWHEEL and self.is_open:
            # Xử lý scroll bằng chuột
            if len(self.options) > self.max_visible_items:
                self.scroll_offset = max(0,
                                         min(self.scroll_offset - event.y, len(self.options) - self.max_visible_items))
        self.update_hover(py.mouse.get_pos())

    def update_hover(self, mouse_pos):
        if self.is_open:  # Nếu dropdown đang mở thì mới kiểm tra
            self.hover_index = -1  # Không di vào gì
            # Chỉ xử lí những thứ đang hiện trên mh
            for i in range(self.scroll_offset, min(self.scroll_offset + self.max_visible_items, len(self.options))):
                # Xác định rect của các lựa chọn đang hiện
                option_rect = py.Rect(
                    self.rect.x,
                    self.rect.y + (i - self.scroll_offset + 1) * self.rect.h,
                    self.rect.w,
                    self.rect.h
                )
                if option_rect.collidepoint(mouse_pos):  # Nếu di chuột vào
                    self.hover_index = i  # Đặt luôn hover_index thành i (Tức lựa chọn được di vào)
                    break  # Ngừng kt khi item đã được hover rồi

    def draw(self, surface):
        BG_COLOR = (45, 45, 45)
        BORDER_COLOR = (180, 180, 180)
        TEXT_COLOR = (255, 255, 255)
        ARROW_COLOR = (220, 220, 220)
        HOVER_COLOR = (65, 105, 225)
        ITEM_BG_COLOR = (55, 55, 55)
        py.draw.rect(surface, BG_COLOR, self.rect, border_radius=6)
        py.draw.rect(surface, BORDER_COLOR, self.rect, 2, border_radius=6)
        if self.extension:
            selected_text = shorten_text(self.options[self.selected_index])
        else:
            selected_text = self.options[self.selected_index]

        text_surface = self.font.render(selected_text, True, TEXT_COLOR)
        text_rect = text_surface.get_rect(x=self.rect.x + 10, centery=self.rect.centery)
        surface.blit(text_surface, text_rect)
        center_x = self.rect.right - 15
        center_y = self.rect.centery
        if self.is_open:
            points = [(center_x - 6, center_y - 3), (center_x + 6, center_y - 3),
                      (center_x, center_y + 4)]  # Lấy 3 cạnh của TGC
        else:
            points = [(center_x - 6, center_y + 3), (center_x + 6, center_y + 3),
                      (center_x, center_y - 4)]  # Lấy 3 cạnh của TGC
        py.draw.polygon(surface, ARROW_COLOR, points)  # Vẽ hình TGC
        if self.is_open:
            # Lặp qua danh sách options nhưng chỉ lấy những option trong khoảng cho phép (tùy theo scroll_offset và số item hiển thị tối đa)
            for i in range(self.scroll_offset, min(self.scroll_offset + self.max_visible_items, len(self.options))):
                # Rect của lựa chọn (tính lại vị trí Y dựa trên i - self.scroll_offset để item luôn vẽ đúng vị trí trong khung dropdown)
                option_rect = py.Rect(
                    self.rect.x,
                    self.rect.y + (i - self.scroll_offset + 1) * self.rect.h,
                    # Dời xuống dưới khung chính, trừ scroll_offset để giữ đúng thứ tự hiển thị
                    self.rect.w,
                    self.rect.h
                )
                # Đặt màu nền: nếu đang di chuột vào item thì dùng HOVER_COLOR, ngược lại dùng ITEM_BG_COLOR
                bg_color = HOVER_COLOR if i == self.hover_index else ITEM_BG_COLOR
                py.draw.rect(surface, bg_color, option_rect, border_radius=4)  # Vẽ màu nền
                py.draw.rect(surface, BORDER_COLOR, option_rect, 1, border_radius=4)  # Vẽ outline viền cho option

                # Biến text để vẽ lên (nội dung chính là self.options[i])
                if self.extension:
                    option_text = shorten_text(self.options[i])
                else:
                    option_text = self.options[i]

                text_surface = self.font.render(option_text, True, TEXT_COLOR)

                # Rect của text: đặt text lệch 10px từ trái, và căn giữa theo chiều cao của option_rect
                text_rect = text_surface.get_rect(x=option_rect.x + 10, centery=option_rect.centery)
                surface.blit(text_surface, text_rect)  # Vẽ text lên màn hình


# SETTING SLIDER + INPUT
volume_slider = Slider(225, 300, 150, 20, value=0.5, min_val=0, max_val=1, knob_radius=14)
volume_input = InputBox(270, 340, 60, 40, text='50')

# ADV SETTING SLIDER + INPUT
dark_slider = Slider(225, 550, 150, 20, value=0, min_val=0, max_val=170, knob_radius=14)
dark_input = InputBox(270, 590, 60, 40, text='0', min_val=0, max_val=170, multiplier=170)
firework_slider = Slider(430, 550, 150, 20, value=0, min_val=0, max_val=50, knob_radius=14, integer=True)
firework_input = InputBox(475, 590, 60, 40, text='10', min_val=0, max_val=50, multiplier=50)
sfx_slider = Slider(620, 550, 150, 20, value=1, min_val=0, max_val=1, knob_radius=14)
sfx_input = InputBox(665, 590, 60, 40, text='100', min_val=0, max_val=100, multiplier=1)

# VISUAL SETTINGS SLIDER + INPUT
red_slider = Slider(100, 100, 250, 20, value=0, min_val=0, max_val=255, knob_radius=14, integer=True, offset=50)
green_slider = Slider(100, 200, 250, 20, value=166, min_val=0, max_val=255, knob_radius=14, integer=True, offset=50)
blue_slider = Slider(100, 300, 250, 20, value=82, min_val=0, max_val=255, knob_radius=14, integer=True, offset=50)
red_input = InputBox(400, 100, 60, 40, text='0', min_val=0, max_val=255, multiplier=255)
green_input = InputBox(400, 200, 60, 40, text='166', min_val=0, max_val=255, multiplier=255)
blue_input = InputBox(400, 300, 60, 40, text='82', min_val=0, max_val=255, multiplier=255)

save_input = InputBox(325, 400, 250, 50, text='', num_val=False, lost_focus=True)
# DROPDOWN CONFIG
font = py.font.SysFont('Arial', 25)
language_dropdown = Dropdown(390, 300, 150, 40, ['ENGLISH', 'T. Việt'], 'ENGLISH', font)
difficulty_dropdown = Dropdown(550, 300, 150, 40, [
    'EASY', 'MEDIUM', 'HARD', 'INSANE', 'EXTREME'
], 'MEDIUM', font)
color_dropdown = Dropdown(700, 150, 170, 40, [
    'Default', 'Green', 'Sky blue',
    'Red', 'Yellow', 'Orange', 'White',
    'Black', 'Light green', 'Purple', 'Dark', 'Rainbow',
    'Custom',
], 'Default', font, extension=False)
saved_color_dropdown = Dropdown(500, 150, 170, 40, ['Default'], 'Default', font)
previous_color_idx = 0
clock = py.time.Clock()


def save_config(save_list, saved_color_list):
    try:
        config = {
            "TOGGLE MUSIC": toggle_music,
            "TOGGLE SFX": toggle_sfx,
            "TOGGLE fireworks": toggle_fireworks,
            "TOGGLE BRIGHTNESS": toggle_brightness,
            "TOGGLE FPS": toggle_fps,
            "TOGGLE PLAYER_MARK": toggle_visible_collision,
            "TOGGLE DISPLAY SPEED": toggle_display_speed,
            "P1 SKIN": p1_skin,
            "P2 SKIN": p2_skin,
            "LANGUAGE": language,
            "save_list": save_list,
            "saved_color_list": [list(c) for c in saved_color_list],
            "P1_PERK": current_p1_perk_idx,
            "P2_PERK": current_p2_perk_idx,
            "COLOR_SELECTED_INDEX": color_dropdown.selected_index,
            "toggle_dark_mode": toggle_dark_mode,
            "RED": int(red_slider.value),
            "GREEN": int(green_slider.value),
            "BLUE": int(blue_slider.value),
            "BRIGHTNESS": min(int(dark_slider.value), 170),
            "VOLUME": volume_slider.value,
            "SFX": sfx_slider.value,
            "fireworks": min(int(firework_slider.value), 50)
        }
        with open(CONFIG_FILE, "w", encoding="utf-8") as f:
            json.dump(config, f, indent=4, ensure_ascii=False)
        print("Đã lưu config:", config)
    except Exception as e:
        print("Lỗi khi lưu config:", e)


def load_config():
    try:
        with open(CONFIG_FILE, "r", encoding="utf-8") as f:
            config = json.load(f)
        global toggle_music, toggle_sfx, toggle_fireworks, toggle_brightness
        global toggle_fps, toggle_visible_collision, toggle_display_speed, toggle_dark_mode
        global p1_skin, p2_skin, LANGUAGE
        global current_p1_perk_idx, current_p2_perk_idx

        toggle_music = config.get("toggle_music", True)
        toggle_sfx = config.get("toggle_sfx", True)
        toggle_fireworks = config.get("toggle_fireworks", True)
        toggle_brightness = config.get("toggle_brightness", False)
        toggle_fps = config.get("toggle_fps", True)
        toggle_visible_collision = config.get("toggle_visible_collision", True)
        toggle_display_speed = config.get("toggle_display_speed", False)
        toggle_dark_mode = config.get("toggle_dark_mode", False)
        red_slider.value = config.get("RED", 30)
        blue_slider.value = config.get("BLUE", 30)
        green_slider.value = config.get("GREEN", 30)
        dark_slider.value = config.get("BRIGHTNESS", 0)
        firework_slider.value = config.get("fireworks", 0)
        volume_slider.value = config.get("VOLUME", 0.5)
        sfx_slider.value = config.get("SFX", 0.5)
        p1_skin = config.get("p1_skin", "Default")
        p2_skin = config.get("p2_skin", "Default")
        LANGUAGE = config.get("LANGUAGE", "ENGLISH")
        if LANGUAGE in ["ENGLISH", "T.Việt"]:
            pass
        else:
            LANGUAGE = 'ENGLISH'
        # load perks
        current_p1_perk_idx = config.get("P1_PERK")
        current_p2_perk_idx = config.get("P2_PERK")

        try:
            if current_p1_perk_idx > pk.get_perks_length():
                current_p1_perk_idx = 0
            if current_p2_perk_idx > pk.get_perks_length():
                current_p2_perk_idx = 0
        except Exception as e:
            current_p1_perk_idx = 0
            current_p2_perk_idx = 0
            print(f'Đã chặn lỗi: {e}')
        save_list = config.get("save_list", []) or ["Default"]
        saved_color_list = [tuple(c) for c in config.get("saved_color_list", [])] or [(0, 166, 82)]

        selected_index = config.get("COLOR_SELECTED_INDEX", 0)
        if 0 <= selected_index < len(color_dropdown.options):
            color_dropdown.selected_index = selected_index
        else:
            color_dropdown.selected_index = 0  # fallback an toàn
        print('Đã load config thành công!')
        return save_list, saved_color_list
    except FileNotFoundError:
        return ["Default"], [(0, 166, 82)]
    except Exception as e:
        print("Lỗi khi load config:", e)
        return ["Default"], [(0, 166, 82)]


def spawn_rock(NUM, TEAM):
    for _ in range(NUM):
        while True:
            if TEAM == 1:
                ROCK_X = random.randint(700, 900)
                ROCK_Y = random.randint(130, 350)
            else:
                ROCK_X = random.randint(700, 900)
                ROCK_Y = random.randint(430, 620)
            new_rock_rect = ROCK_IMG.get_rect(topleft=(ROCK_X, ROCK_Y))
            collision = False
            for existing_rock in rocks:
                existing_rock_rect = ROCK_IMG.get_rect(topleft=(existing_rock[0], existing_rock[1]))
                if new_rock_rect.colliderect(existing_rock_rect):
                    collision = True
                    break
            if not collision:
                rocks.append([ROCK_X, ROCK_Y])
                break


def check_collision():
    global speed_for_player1, speed_for_player2
    global x_energy_ball1, x_energy_ball2, y_energy_ball1, y_energy_ball2
    global energy_ball1_is_visible, energy_ball2_is_visible, energy_ball_timer1, energy_ball_timer2
    global energy_player1, energy_player2
    global flashstepping, flashstepping2
    global timestopping, timestopping2
    global absorption_pack, absorption_pack2
    P1_HITBOX = YELLOW_SHIP_G.get_rect(topleft=(0, y_player1))
    P2_HITBOX = GREEN_SHIP_G.get_rect(topleft=(0, y_player2))
    backend_perks = pk.get_perks('ENGLISH')
    for ROCK in rocks:
        ROCK_COLLIDE_BOX = ROCK_IMG.get_rect(topleft=(ROCK[0], ROCK[1]))
        if P1_HITBOX.colliderect(ROCK_COLLIDE_BOX) and (not timestopping and not flashstepping):
            ROCK[0] = -10000
            if toggle_sfx:
                ROCK_SOUND.play(0)
            if 'Speeds' in backend_perks[current_p1_perk_idx]:
                speed_for_player1 = -5
            elif backend_perks[current_p1_perk_idx] == 'Reduce Slowness':
                speed_for_player1 = max(0.1, speed_for_player1 - (4 * .1))
            elif backend_perks[current_p1_perk_idx] == 'Rage':
                energy_player1 += 8
                speed_for_player1 = max(0.1, speed_for_player1 - 3)
            elif 'Absorption' in backend_perks[current_p1_perk_idx]:
                if absorption_pack[0] > 0:
                    absorption_pack[0] = max(0, absorption_pack[0] - 1)
                    speed_for_player1 = max(40, speed_for_player1 + 3)
                    print(f'{absorption_pack[0]} charges left')
                else:  # Out of charges
                    speed_for_player1 = max(0.1, speed_for_player1 - 4)
            else:
                speed_for_player1 = max(0.1, speed_for_player1 - 4)
        if P2_HITBOX.colliderect(ROCK_COLLIDE_BOX) and (not timestopping2 and not flashstepping2):
            ROCK[0] = -10000
            if toggle_sfx:
                ROCK_SOUND.play(0)
            if 'Speeds' in backend_perks[current_p2_perk_idx]:
                speed_for_player2 = -5
            elif backend_perks[current_p2_perk_idx] == 'Reduce Slowness':
                speed_for_player2 = max(0.1, speed_for_player2 - (4 * .1))
            elif 'Absorption' in backend_perks[current_p2_perk_idx]:
                if absorption_pack2[0] > 0:
                    absorption_pack2[0] = max(0, absorption_pack2[0] - 1)
                    speed_for_player2 = max(35, speed_for_player2 + 3)
                    print(f'{absorption_pack2[0]} charges left')
                else:  # Out of charges
                    speed_for_player2 = max(0.1, speed_for_player1 - 4)
            else:
                if backend_perks[current_p2_perk_idx] == 'Rage':
                    energy_player2 += 8
                speed_for_player2 = max(0.1, speed_for_player2 - 4)
    if energy_ball1_is_visible:
        BALL_COLLISION_1 = ENERGY_BALL.get_rect(topleft=(x_energy_ball1, y_energy_ball1))
        if P1_HITBOX.colliderect(BALL_COLLISION_1):
            if 'Speeds' in backend_perks[current_p1_perk_idx]:
                energy_player1 += 10
            else:
                energy_player1 += 25
            energy_ball1_is_visible = False
            energy_ball_timer1 = py.time.get_ticks()
            if toggle_sfx:
                ENERGY_BALL_SOUND.play(0)
    if energy_ball2_is_visible:
        BALL_COLLISION_2 = ENERGY_BALL.get_rect(topleft=(x_energy_ball2, y_energy_ball2))
        if P2_HITBOX.colliderect(BALL_COLLISION_2):
            if 'Speeds' in backend_perks[current_p2_perk_idx]:
                energy_player2 += 10
            else:
                energy_player2 += 25
            energy_ball2_is_visible = False
            energy_ball_timer2 = py.time.get_ticks()
            if toggle_sfx:
                ENERGY_BALL_SOUND.play(0)


def firework_spawner(NUM):
    for _ in range(NUM):
        X_POSITION = random.randint(200, 700)
        Y_POSITION = random.randint(600, 900)
        FIREWORK_SPEED = random.randint(5, 10)
        MAXIMUM_Y = random.randint(150, 250)
        fireworks.append([X_POSITION, Y_POSITION, FIREWORK_SPEED, MAXIMUM_Y])


def update_fireworks(dt=1):
    global fireworks
    new_fireworks = []
    for firework in fireworks:
        firework[1] -= firework[2] * dt
        screen.blit(FIREWORK_IMG, (firework[0], firework[1]))
        if firework[1] > firework[3]:
            new_fireworks.append(firework)
    fireworks = new_fireworks


def reset_game():
    global x_bg, y_player1, y_player2, x_wave1, x_wave2
    global speed_for_player1, speed_for_player2, rocks, fireworks
    global player1_ball_x, player2_ball_x
    global x_energy_ball1, x_energy_ball2, y_energy_ball1, y_energy_ball2
    global energy_ball1_is_visible, energy_ball2_is_visible
    global energy_ball_timer1, energy_ball_timer2
    global winner_text
    global distance_to_finish_line1, distance_to_finish_line2
    global energy_player1, energy_player2
    global flashstepping, flashstepping2
    global timestopping, timestopping2
    global last_flashstep, last_flashstep2
    global last_ts, last_ts2
    global ts_start, ts_start2
    global flashstep_start, flashstep_start2
    global absorption_pack, absorption_pack2, timestop_pack, timestop_pack2, flashstep_pack, flashstep_pack2
    global ability_counts, ability_counts2, last_create_rocks, last_create_rocks2, create_rocks_start, create_rocks_start2
    # Packages for both players
    absorption_pack = pk.get_manual_use_ability('Absorption')
    timestop_pack = pk.get_manual_use_ability('Timestop')
    flashstep_pack = pk.get_manual_use_ability('Flash Step')

    absorption_pack2 = pk.get_manual_use_ability('Absorption')
    timestop_pack2 = pk.get_manual_use_ability('Timestop')
    flashstep_pack2 = pk.get_manual_use_ability('Flash Step')
    # Special Perks for P1
    timestopping2 = False
    flashstepping2 = False
    last_flashstep2 = -99999
    last_ts2 = -9999
    flashstep_start2 = 0
    ts_start2 = 0
    # Special Perks for P2
    timestopping = False
    flashstepping = False
    last_flashstep = -99999
    last_ts = -9999
    flashstep_start = 0
    ts_start = 0
    # Dark Magic
    last_create_rocks = -9999
    create_rocks_start = 0
    ability_counts = 0
    # Dark Magic for P2
    last_create_rocks2 = -9999
    create_rocks_start2 = 0
    ability_counts2 = 0
    distance_to_finish_line1 = 0
    distance_to_finish_line2 = 0
    x_bg = 0
    y_player1 = 250
    y_player2 = 500
    x_wave1 = 0
    x_wave2 = 0
    speed_for_player1 = 5
    speed_for_player2 = 5
    energy_player1 = energy_player2 = 0
    if toggle_music:
        BG_music.stop()
        GAME_music.play(-1)
    rocks = []
    fireworks = []
    num_rocks = 0
    if DIFFICULTY == 'EASY' or DIFFICULTY == 'DỄ':
        num_rocks = 1
    elif DIFFICULTY == 'MEDIUM' or DIFFICULTY == 'THƯỜNG':
        num_rocks = 3
    elif DIFFICULTY == 'HARD' or DIFFICULTY == 'KHÓ':
        num_rocks = 5
    elif DIFFICULTY == 'INSANE' or DIFFICULTY == 'ĐIÊN LOẠN':
        num_rocks = 7
    elif DIFFICULTY == 'EXTREME' or DIFFICULTY == 'CỰC KHÓ':
        num_rocks = 9
    spawn_rock(num_rocks, 1)
    spawn_rock(num_rocks, 2)
    player1_ball_x = 250
    player2_ball_x = 250
    x_energy_ball1 = 900
    x_energy_ball2 = 900
    y_energy_ball1 = random.randint(130, 350)
    y_energy_ball2 = random.randint(430, 620)
    energy_ball1_is_visible = True
    energy_ball2_is_visible = True
    energy_ball_timer1 = 0
    energy_ball_timer2 = 0
    winner_text = None


def draw_toggle(x, y, status, text_en, text_vi, on_img_en, off_img_en, on_img_vi, off_img_vi):
    text_to_render = text_vi if LANGUAGE == 'T. Việt' else text_en
    text_surface = font.render(text_to_render, True, (0, 0, 0) if not toggle_dark_mode else (255, 255, 255))
    text_rect = text_surface.get_rect(topleft=(x, y))
    screen.blit(text_surface, text_rect)
    img = on_img_en if status and LANGUAGE == 'ENGLISH' else off_img_en if not status and LANGUAGE == 'ENGLISH' else on_img_vi if status else off_img_vi
    rect = img.get_rect(topleft=(x, y + 50))
    screen.blit(img, rect)
    return rect


def display():
    global toggle_fps, toggle_brightness, CLOSE, CLOSE_BOX, state
    global dark_surface
    if state != 'MENU':
        screen.blit(CLOSE, CLOSE.get_rect(center=CLOSE_BOX.center))
    if toggle_fps:
        fps_text = font.render(f"FPS: {int(clock.get_fps())}", True, (255, 255, 255))
        screen.blit(fps_text, (0, 350))
    if toggle_brightness:
        dark_surface.set_alpha(int(dark_slider.value))
        screen.blit(dark_surface, (0, 0))


def lerp(c1, c2, a):
    return tuple(int(c1[i] + (c2[i] - c1[i]) * a) for i in range(3))


def play_sfx():
    global toggle_sfx
    if toggle_sfx:
        CLICK_sfx.play(0)


def return_text_wrapped(text, font, color, max_width):
    words = text.split(' ')
    lines = []
    current_line = ""

    for word in words:
        test_line = current_line + (" " if current_line else "") + word
        # render thử để đo chiều rộng
        if font.size(test_line)[0] <= max_width:
            current_line = test_line  # nếu < cd tối đa thì viết tiếp
        else:
            lines.append(current_line)  # nếu đã lớn hơn test thì append vào
            current_line = word  # Đặt dòng mới thành từ mà thêm vào sẽ quá max_width
    if current_line:  # còn chữ ở dòng cuối thì thêm vào
        lines.append(current_line)

    # return lại 1 list đã tách chữ
    return [font.render(line, True, color) for line in lines]


def blit_text_wrapped(screen, text, font, color, center_x, center_y, max_width):
    """
    Blit text được wrap tự động lên screen tại vị trí trung tâm

    Args:
        screen: pygame screen surface
        text: text cần hiển thị
        font: pygame font object
        color: màu text (tuple RGB)
        center_x: tọa độ x trung tâm
        center_y: tọa độ y trung tâm
        max_width: chiều rộng tối đa của một dòng
    """
    words = text.split(' ')
    lines = []
    current_line = ""

    # Wrap text thành các dòng
    for word in words:
        test_line = current_line + (" " if current_line else "") + word
        if font.size(test_line)[0] <= max_width:
            current_line = test_line
        else:
            if current_line:  # Tránh dòng rỗng
                lines.append(current_line)
            current_line = word

    if current_line:
        lines.append(current_line)

    # Tính toán vị trí bắt đầu để căn giữa theo chiều dọc
    total_height = len(lines) * font.get_linesize()
    start_y = center_y - total_height // 2

    # Blit từng dòng lên screen
    for i, line in enumerate(lines):
        text_surface = font.render(line, True, color)
        text_rect = text_surface.get_rect(centerx=center_x, y=start_y + i * font.get_linesize())
        screen.blit(text_surface, text_rect)


def shorten_text(text, max_len=8):
    return text if len(text) <= max_len else text[:max_len - 1] + "..."


def draw_energy_bars():
    max_width = 100
    # Player 1
    ratio1 = min(energy_player1 / 100, 1.0)
    py.draw.rect(screen, (255, 255, 0), (0, y_player1 - 20, int(max_width * ratio1), 10))
    py.draw.rect(screen, (255, 255, 255), (0, y_player1 - 20, max_width, 10), 2)

    # Player 2
    ratio2 = min(energy_player2 / 100, 1.0)
    py.draw.rect(screen, (255, 255, 0), (0, y_player2 - 20, int(max_width * ratio2), 10))
    py.draw.rect(screen, (255, 255, 255), (0, y_player2 - 20, max_width, 10), 2)


def set_transparency():
    global CLOSE
    global REPLAY_VI, REPLAY_EN
    global PLAY_VI, PLAY_EN
    global SETTING_EN, SETTING_VI
    global TRASH_BIN
    global triangle, triangle2, triangle3, triangle4
    CLOSE.set_alpha(close_transparency)
    REPLAY_VI.set_alpha(replay_transparency)
    REPLAY_EN.set_alpha(replay_transparency)
    PLAY_EN.set_alpha(play_transparency)
    PLAY_VI.set_alpha(play_transparency)
    SETTING_VI.set_alpha(setting_transparency)
    SETTING_EN.set_alpha(setting_transparency)
    TRASH_BIN.set_alpha(delete_saved_transparency)
    triangle.set_alpha(triangle_transparency)
    triangle2.set_alpha(triangle2_transparency)
    triangle3.set_alpha(triangle3_transparency)
    triangle4.set_alpha(triangle4_transparency)


def set_volume():
    global toggle_music, toggle_sfx
    global BG_music, GAME_music
    if toggle_music:
        BG_music.set_volume(volume_slider.value)
        GAME_music.set_volume(volume_slider.value)
    else:
        BG_music.set_volume(0)
        GAME_music.set_volume(0)
    if toggle_sfx:
        CLICK_sfx.set_volume(sfx_slider.value)
        ROCK_SOUND.set_volume(sfx_slider.value)
        ENERGY_BALL_SOUND.set_volume(sfx_slider.value)
        WIN_sfx.set_volume(sfx_slider.value)
    else:
        ROCK_SOUND.set_volume(0)
        ENERGY_BALL_SOUND.set_volume(0)
        WIN_sfx.set_volume(0)


def set_default_speed(normal, special):
    global backend_perks
    global normal_speed_for_player1, normal_speed_for_player2
    if 'Passive' in backend_perks[current_p1_perk_idx]:
        normal_speed_for_player1 = special
    else:
        normal_speed_for_player1 = normal
    if 'Passive' in backend_perks[current_p2_perk_idx]:
        normal_speed_for_player2 = special
    else:
        normal_speed_for_player2 = normal
    if "Slow" in backend_perks[current_p1_perk_idx]:
        normal_speed_for_player1 = 7
    if "Slow" in backend_perks[current_p2_perk_idx]:
        normal_speed_for_player2 = 7
    if 'Test' in backend_perks[current_p1_perk_idx]:
        normal_speed_for_player1 = 999


def display_plr():
    global p1_skin, p2_skin
    global YELLOW_SHIP_G, GREEN_SHIP_G
    global y_player1, y_player2
    global player1_ball_x, player2_ball_x

    if p1_skin == 'Yellow':
        screen.blit(YELLOW_SHIP_G, (0, y_player1))
        screen.blit(YELLOW_BALL, (player1_ball_x, 5))
    else:
        screen.blit(GREEN_SHIP_G, (0, y_player1))
        screen.blit(GREEN_BALL, (player1_ball_x, 5))
    if p2_skin == 'Green':
        screen.blit(GREEN_SHIP_G, (0, y_player2))
        screen.blit(GREEN_BALL, (player2_ball_x, 50))
    else:
        screen.blit(YELLOW_SHIP_G, (0, y_player2))
        screen.blit(YELLOW_BALL, (player2_ball_x, 50))


save_list, saved_color_list = load_config()
while True:
    MOUSE_POS = py.mouse.get_pos()
    set_volume()
    set_transparency()
    LANGUAGE = language_dropdown.options[language_dropdown.selected_index]
    perks = pk.get_perks(LANGUAGE)
    perk_desc = pk.get_desc(LANGUAGE)
    set_default_speed(6, 9)

    DIFFICULTY = difficulty_dropdown.options[difficulty_dropdown.selected_index]
    color_choice = color_dropdown.options[color_dropdown.selected_index]
    saved_color_choice = saved_color_dropdown.options[saved_color_dropdown.selected_index]
    if color_choice == 'Custom' or color_choice == 'Tùy chỉnh':
        BG_COLOR = (int(red_slider.value), int(green_slider.value), int(blue_slider.value))
    elif color_choice == 'Rainbow' or color_choice == 'Cầu vồng':
        speed = 1
        t = (py.time.get_ticks() / 1000) % (len(rgb_colors) * speed)
        index = int(t // speed)
        next_index = (index + 1) % len(rgb_colors)
        alpha = (t % speed) / speed
        BG_COLOR = lerp(rgb_colors[index], rgb_colors[next_index], alpha)
    else:
        BG_COLOR = colors[color_dropdown.selected_index]

    # FPS BASED
    dt = clock.tick(120) / 1000
    dt_scale = dt * 80
    for event in py.event.get():
        if event.type == py.QUIT:
            save_config(save_list, saved_color_list)
            py.quit()
            sys.exit()
        # ===== MENU =====
        if state == 'MENU':
            if PLAY_BOX.collidepoint(MOUSE_POS):
                play_transparency = 150
                if event.type == py.MOUSEBUTTONDOWN and event.button == 1:
                    state = 'BASE'
                    play_sfx()
                    reset_game()
            elif SETTING_BOX.collidepoint(MOUSE_POS):
                setting_transparency = 150
                if event.type == py.MOUSEBUTTONDOWN and event.button == 1:
                    play_sfx()
                    state = 'SETTINGS'
            else:
                play_transparency = 255
                setting_transparency = 255

        # ===== SETTINGS =====
        elif state == 'SETTINGS':
            if CLOSE_BOX.collidepoint(MOUSE_POS):
                close_transparency = 150
                if event.type == py.MOUSEBUTTONDOWN and event.button == 1:
                    state = 'MENU'
                    play_sfx()
                    if toggle_music:
                        GAME_music.stop()
            else:
                close_transparency = 255
            buttons[0].centerx = screen.get_width() // 2
            buttons[0].y = 550
            if buttons[0].collidepoint(MOUSE_POS):
                if event.type == py.MOUSEBUTTONDOWN and event.button == 1:
                    state = 'ADV SETTINGS'
                    play_sfx()
            volume_slider.handle_event(event)
            volume_input.handle_event(event, volume_slider)
            volume_input.text = str(int(volume_slider.value * 100))
            language_dropdown.handle_event(event)
            difficulty_dropdown.handle_event(event)
        elif state == 'ADV SETTINGS':
            if CLOSE_BOX.collidepoint(MOUSE_POS):
                close_transparency = 150
                if event.type == py.MOUSEBUTTONDOWN and event.button == 1:
                    state = 'SETTINGS'
                    play_sfx()
                    if toggle_music:
                        GAME_music.stop()
            else:
                close_transparency = 255
            dark_slider.handle_event(event)
            dark_input.handle_event(event, dark_slider)
            dark_input.text = str(int(dark_slider.value))
            firework_slider.handle_event(event)
            firework_input.handle_event(event, firework_slider)
            firework_input.text = str(int(firework_slider.value))
            sfx_slider.handle_event(event)
            sfx_input.handle_event(event, sfx_slider)
            sfx_input.text = str(int(sfx_slider.value * 100))
            if event.type == py.MOUSEBUTTONDOWN and event.button == 1:
                mouse_x, mouse_y = event.pos
                if draw_toggle(200, 100, toggle_music, 'Music', 'Âm nhạc', toggle_ON_EN, toggle_OFF_EN, toggle_ON_VI,
                               toggle_OFF_VI).collidepoint(mouse_x, mouse_y):
                    toggle_music = not toggle_music
                    play_sfx()
                elif draw_toggle(200, 250, toggle_sfx, 'Sound Effects', 'H.Ứng âm thanh', toggle_ON_EN,
                                 toggle_OFF_EN, toggle_ON_VI, toggle_OFF_VI).collidepoint(mouse_x, mouse_y):
                    toggle_sfx = not toggle_sfx
                    play_sfx()
                elif draw_toggle(200, 400, toggle_fireworks, 'Fireworks', 'Pháo hoa', toggle_ON_EN, toggle_OFF_EN,
                                 toggle_ON_VI, toggle_OFF_VI).collidepoint(mouse_x, mouse_y):
                    toggle_fireworks = not toggle_fireworks
                    play_sfx()
                elif draw_toggle(400, 100, toggle_display_speed, 'Speed Display', 'Hiển thị tốc độ', toggle_ON_EN,
                                 toggle_OFF_EN, toggle_ON_VI, toggle_OFF_VI).collidepoint(mouse_x, mouse_y):
                    toggle_display_speed = not toggle_display_speed
                    play_sfx()
                elif draw_toggle(400, 250, toggle_dark_mode, 'Dark Mode', 'Chế độ tối', toggle_ON_EN, toggle_OFF_EN,
                                 toggle_ON_VI, toggle_OFF_VI).collidepoint(mouse_x, mouse_y):
                    toggle_dark_mode = not toggle_dark_mode
                    play_sfx()
                    if toggle_dark_mode:
                        previous_color_idx = color_dropdown.selected_index  # lưu màu hiện tại
                        color_dropdown.selected_index = 10
                    else:
                        color_dropdown.selected_index = previous_color_idx  # khôi phục màu cũ
                elif draw_toggle(600, 100, toggle_brightness, 'Brightness', 'Nền tối', toggle_ON_EN, toggle_OFF_EN,
                                 toggle_ON_VI, toggle_OFF_VI).collidepoint(mouse_x, mouse_y):
                    toggle_brightness = not toggle_brightness
                    play_sfx()
                elif draw_toggle(600, 250, toggle_fps, 'Show FPS', 'Hiện FPS', toggle_ON_EN, toggle_OFF_EN,
                                 toggle_ON_VI, toggle_OFF_VI).collidepoint(mouse_x, mouse_y):
                    toggle_fps = not toggle_fps
                    play_sfx()
                elif draw_toggle(400, 400, toggle_visible_collision, "Players' Mark", 'Đánh dấu N.chơi', toggle_ON_EN,
                                 toggle_OFF_EN, toggle_ON_VI, toggle_OFF_VI).collidepoint(mouse_x, mouse_y):
                    toggle_visible_collision = not toggle_visible_collision
                    play_sfx()
                elif buttons[1].collidepoint(MOUSE_POS):
                    state = 'VSETTINGS'
                    play_sfx()
                elif buttons[3].collidepoint(MOUSE_POS):
                    state = 'PSETTINGS'
                    play_sfx()
        elif state == 'VSETTINGS':
            if CLOSE_BOX.collidepoint(MOUSE_POS):
                close_transparency = 150
                if event.type == py.MOUSEBUTTONDOWN and event.button == 1:
                    state = 'ADV SETTINGS'
                    play_sfx()
                    if toggle_music:
                        GAME_music.stop()
            else:
                close_transparency = 255
            red_slider.handle_event(event)
            red_input.handle_event(event, red_slider)
            red_input.text = str(int(red_slider.value))
            green_slider.handle_event(event)
            green_input.handle_event(event, green_slider)
            green_input.text = str(int(green_slider.value))
            blue_slider.handle_event(event)
            blue_input.handle_event(event, blue_slider)
            blue_input.text = str(int(blue_slider.value))
            save_input.handle_event(event)
            color_dropdown.handle_event(event)
            saved_color_dropdown.handle_event(event)
            saved_color_dropdown.options = save_list
            if ((color_choice != 'Custom' and color_choice != 'Tùy chỉnh')
                    and (color_choice != 'Rainbow' and color_choice != 'Cầu vồng')):
                try:
                    preset_color = colors[color_dropdown.selected_index]
                    red_slider.value = preset_color[0]
                    green_slider.value = preset_color[1]
                    blue_slider.value = preset_color[2]
                except IndexError:
                    pass
            else:
                preset_color = None
            if saved_color_choice != 'Default' and saved_color_choice != 'Mặc định':
                try:
                    saved_color_index = save_list.index(saved_color_choice)
                    saved_color = saved_color_list[saved_color_index]
                    red_slider.value = saved_color[0]
                    green_slider.value = saved_color[1]
                    blue_slider.value = saved_color[2]
                    color_dropdown.selected_index = color_dropdown.options.index(
                        'Custom' if LANGUAGE == 'ENGLISH' else 'Tùy chỉnh')
                except (IndexError, ValueError):
                    pass
            if (color_choice == 'Black' or color_choice == 'Đen' or BG_COLOR == (0, 0, 0)
                    or BG_COLOR == (30, 30, 30) or color_choice == 'Dark' or color_choice == 'Tối'
                    or (BG_COLOR[0] <= 30 and BG_COLOR[1] <= 30 and BG_COLOR[2] <= 30)):
                toggle_dark_mode = True
            else:
                toggle_dark_mode = False
            if buttons[2].collidepoint(MOUSE_POS):
                if event.type == py.MOUSEBUTTONDOWN and event.button == 1:
                    save_name = save_input.text
                    if save_name != '':
                        if save_name not in save_list:
                            save_list.append(save_name)
                            saved_color_list.append(
                                (int(red_slider.value), int(green_slider.value), int(blue_slider.value)))
            if TRASH_BOX.collidepoint(MOUSE_POS):
                delete_saved_transparency = 150
                if event.type == py.MOUSEBUTTONDOWN and event.button == 1:
                    if saved_color_choice != 'Default' and saved_color_choice != 'Mặc định':
                        try:
                            saved_color_index = save_list.index(saved_color_choice)
                            save_list.pop(saved_color_index)
                            saved_color_list.pop(saved_color_index)
                            saved_color_dropdown.selected_index = 0
                            save_config(save_list, saved_color_list)
                        except (IndexError, ValueError):
                            pass
            else:
                delete_saved_transparency = 255
        elif state == 'PSETTINGS':
            triangle_SURFACE.set_alpha(0)
            triangle_SURFACE2.set_alpha(0)
            triangle_SURFACE3.set_alpha(0)
            triangle_SURFACE4.set_alpha(0)

            if CLOSE_BOX.collidepoint(MOUSE_POS):
                close_transparency = 150
                if event.type == py.MOUSEBUTTONDOWN and event.button == 1:
                    state = 'ADV SETTINGS'
                    play_sfx()
            else:
                close_transparency = 250
            if triangle_BOX.collidepoint(MOUSE_POS):
                triangle_transparency = 150
                if event.type == py.MOUSEBUTTONDOWN and event.button == 1:
                    play_sfx()
                    triangle_SURFACE.fill((0, 0, 0))
                    triangle_SURFACE.set_alpha(100)
                    if p1_skin == 'Yellow':
                        p1_skin = 'Green'
                    else:
                        p1_skin = 'Yellow'
            else:
                triangle_transparency = 255
            if triangle_BOX2.collidepoint(MOUSE_POS):
                triangle2_transparency = 150
                if event.type == py.MOUSEBUTTONDOWN and event.button == 1:
                    play_sfx()
                    triangle_SURFACE2.fill((0, 0, 0))
                    triangle_SURFACE2.set_alpha(100)
                    if p2_skin == 'Green':
                        p2_skin = 'Yellow'
                    else:
                        p2_skin = 'Green'
            else:
                triangle2_transparency = 255
            if triangle_BOX3.collidepoint(MOUSE_POS):
                triangle3_transparency = 150
                if event.type == py.MOUSEBUTTONDOWN and event.button == 1:
                    play_sfx()
                    triangle_SURFACE3.fill((0, 0, 0))
                    triangle_SURFACE3.set_alpha(100)
                    current_p1_perk_idx = (current_p1_perk_idx + 1) % len(perks)
            else:
                triangle3_transparency = 255
            if triangle_BOX4.collidepoint(MOUSE_POS):
                triangle4_transparency = 150
                if event.type == py.MOUSEBUTTONDOWN and event.button == 1:
                    play_sfx()
                    triangle_SURFACE4.fill((0, 0, 0))
                    triangle_SURFACE4.set_alpha(100)
                    current_p2_perk_idx = (current_p2_perk_idx + 1) % len(perks)
            else:
                triangle4_transparency = 255

        # ===== IN GAME =====
        elif state == 'BASE':
            if CLOSE_BOX.collidepoint(MOUSE_POS):
                close_transparency = 150
                if event.type == py.MOUSEBUTTONDOWN and event.button == 1:
                    state = 'MENU'
                    play_sfx()
                    if toggle_music:
                        GAME_music.stop()
                        BG_music.play(-1)
            elif py.Rect(0, 0, 165, 50).collidepoint(MOUSE_POS):
                setting_transparency = 150
                if event.type == py.MOUSEBUTTONDOWN and event.button == 1:
                    state = 'SETTINGS'
                    play_sfx()
                    if toggle_music:
                        GAME_music.stop()
                        BG_music.play(-1)
            else:
                close_transparency = setting_transparency = 255

        # ===== END GAME =====
        elif state == 'END':
            if REPLAY_BOX.collidepoint(MOUSE_POS):
                replay_transparency = 150
                if event.type == py.MOUSEBUTTONDOWN and event.button == 1:
                    play_sfx()
                    state = 'BASE'
                    if toggle_music:
                        GAME_music.stop()
                        GAME_music.play(-1)
                    reset_game()
            elif buttons[12].collidepoint(MOUSE_POS):
                setting_transparency = 150
                if event.type == py.MOUSEBUTTONDOWN and event.button == 1:
                    state = 'SETTINGS'
                    play_sfx()
            else:
                replay_transparency = 255
                setting_transparency = 255

    # ===== MENU =====
    if state == 'MENU':
        screen.fill(BG_COLOR)

        if LANGUAGE == 'ENGLISH':
            screen.blit(MENU_BG_EN, (0, 0))
            screen.blit(PLAY_EN, (190, 380))
            screen.blit(SETTING_EN, (490, 380))
            py.display.set_caption('Dragon Boat Race')
        else:
            screen.blit(MENU_BG_VI, (0, 0))
            screen.blit(PLAY_VI, (190, 380))
            screen.blit(SETTING_VI, (490, 380))
            py.display.set_caption('Đua thuyền rồng')
        display()

    # ===== SETTINGS =====
    elif state == 'SETTINGS':
        screen.fill(BG_COLOR)

        if LANGUAGE == 'ENGLISH':
            screen.blit(SETTING_MENU_EN, (0, 0))
        else:
            screen.blit(SETTING_MENU_VI, (0, 0))
        volume_slider.draw(screen, font, 'Volume' if LANGUAGE == 'ENGLISH' else 'Âm lượng', toggle_dark_mode)
        volume_input.draw(screen)
        language_dropdown.draw(screen)
        difficulty_options = ['EASY', 'MEDIUM', 'HARD', 'INSANE',
                              'EXTREME'] if LANGUAGE == 'ENGLISH' else ['DỄ', 'THƯỜNG', 'KHÓ',
                                                                        'ĐIÊN LOẠN', 'CỰC KHÓ']
        difficulty_dropdown.options = difficulty_options
        difficulty_dropdown.draw(screen)
        buttons[0].centerx = screen.get_width() // 2
        buttons[0].y = 550
        py.draw.rect(screen, (255, 255, 0), buttons[0])
        ADVANCED_SETTINGS_TEXT = font.render(
            'ADVANCED SETTINGS' if LANGUAGE == 'ENGLISH' else 'CÀI ĐẶT NÂNG CAO', True, (0, 0, 0))
        screen.blit(ADVANCED_SETTINGS_TEXT, ADVANCED_SETTINGS_TEXT.get_rect(center=buttons[0].center))
        display()
    elif state == 'ADV SETTINGS':
        screen.fill(BG_COLOR)
        if toggle_brightness:
            dark_surface = py.Surface((900, 680))
            dark_surface.fill((0, 0, 0))
            dark_surface.set_alpha(int(dark_slider.value))
            screen.blit(dark_surface, (0, 0))
        draw_toggle(200, 100, toggle_music, 'Music', 'Âm nhạc', toggle_ON_EN, toggle_OFF_EN, toggle_ON_VI,
                    toggle_OFF_VI)
        draw_toggle(200, 250, toggle_sfx, 'Sound Effects', 'H.Ứng âm thanh', toggle_ON_EN, toggle_OFF_EN,
                    toggle_ON_VI, toggle_OFF_VI)
        draw_toggle(200, 400, toggle_fireworks, 'Fireworks', 'Pháo hoa', toggle_ON_EN, toggle_OFF_EN, toggle_ON_VI,
                    toggle_OFF_VI)
        draw_toggle(600, 100, toggle_brightness, 'Brightness (Light to Dark)', 'Độ sáng (Sáng đến tối)', toggle_ON_EN,
                    toggle_OFF_EN, toggle_ON_VI,
                    toggle_OFF_VI)
        draw_toggle(600, 250, toggle_fps, 'Show FPS', 'Hiện FPS', toggle_ON_EN, toggle_OFF_EN, toggle_ON_VI,
                    toggle_OFF_VI)
        draw_toggle(400, 400, toggle_visible_collision, "Highlight Players", 'Đánh dấu người chơi', toggle_ON_EN, toggle_OFF_EN,
                    toggle_ON_VI, toggle_OFF_VI)
        draw_toggle(400, 100, toggle_display_speed, 'Speed Display', 'Hiển thị tốc độ', toggle_ON_EN, toggle_OFF_EN,
                    toggle_ON_VI, toggle_OFF_VI)
        draw_toggle(400, 250, toggle_dark_mode, 'Dark Mode', 'Chế độ tối', toggle_ON_EN, toggle_OFF_EN, toggle_ON_VI,
                    toggle_OFF_VI)

        dark_slider.draw(screen, font, 'Brightness' if LANGUAGE == 'ENGLISH' else 'Độ sáng',
                         toggle_dark_mode)
        dark_input.draw(screen)
        firework_slider.draw(screen, font, 'Fireworks' if LANGUAGE == 'ENGLISH' else 'Pháo hoa',
                             toggle_dark_mode)
        firework_input.draw(screen)
        sfx_slider.draw(screen, font, 'SFX', toggle_dark_mode)
        sfx_input.draw(screen)
        py.draw.rect(screen, (255, 255, 0), buttons[1])
        bg_text = font.render('Background' if LANGUAGE == 'ENGLISH' else 'Nền',
                              True, (255, 255, 255) if toggle_dark_mode else (0, 0, 0))
        bg_lines = return_text_wrapped(
            'Back ground' if LANGUAGE == 'ENGLISH' else 'Nền',
            font,
            (0, 0, 0),
            100
        )
        player_config_lines = return_text_wrapped(
            'Player' if LANGUAGE == 'ENGLISH' else 'Người chơi',
            font,
            (0, 0, 0),
            100
        )
        bg_y = buttons[1].centery - (len(bg_lines) * font.get_linesize()) // 2

        for line in bg_lines:
            rect = line.get_rect(centerx=buttons[1].centerx, y=bg_y)
            screen.blit(line, rect)
            bg_y += font.get_linesize()

        py.draw.rect(screen, (255, 255, 0), buttons[3])
        plr_config_y = buttons[3].centery - (len(player_config_lines) * font.get_linesize() // 2)

        for line in player_config_lines:
            rect = line.get_rect(centerx=buttons[3].centerx, y=plr_config_y)
            screen.blit(line, rect)
            plr_config_y += font.get_linesize()
        display()
    elif state == 'VSETTINGS':
        screen.fill(BG_COLOR)
        red_slider.draw(screen, font, 'Red' if LANGUAGE == 'ENGLISH' else 'Đỏ', toggle_dark_mode)
        green_slider.draw(screen, font, 'Green' if LANGUAGE == 'ENGLISH' else 'Xanh lục', toggle_dark_mode)
        blue_slider.draw(screen, font, 'Blue' if LANGUAGE == 'ENGLISH' else 'Xanh dương', toggle_dark_mode)
        red_input.draw(screen)
        green_input.draw(screen)
        blue_input.draw(screen)
        save_input.draw(screen)
        color_options = [
            'Default', 'Green', 'Sky blue',
            'Red', 'Yellow', 'Orange', 'White',
            'Black', 'Light green', 'Purple', 'Dark', 'Rainbow', 'Custom'
        ] if LANGUAGE == 'ENGLISH' else [
            'Mặc định', 'Xanh lục', 'Xanh lam',
            'Đỏ', 'Vàng', 'Cam', 'Trắng',
            'Đen', 'Xanh nhạt', 'Tím', 'Tối', 'Cầu vồng', 'Tùy chỉnh'
        ]
        color_dropdown.options = color_options
        color_dropdown.draw(screen)
        saved_color_dropdown.draw(screen)
        py.draw.rect(screen, (255, 255, 0), buttons[2])
        note_text = font.render('Scrollable!' if LANGUAGE == 'ENGLISH' else 'Kéo được!', True,
                                (255, 255, 255) if toggle_dark_mode else (0, 0, 0))
        save_text = font.render('Save!' if LANGUAGE == 'ENGLISH' else 'Lưu!', True,
                                (255, 255, 255) if toggle_dark_mode else (0, 0, 0))
        screen.blit(note_text, (500, 120))
        screen.blit(note_text, (700, 120))
        screen.blit(save_text, save_text.get_rect(center=buttons[2].center))
        screen.blit(TRASH_BIN, (600, 400))
        display()
    elif state == 'PSETTINGS':
        screen.fill(BG_COLOR)
        if p1_skin == 'Yellow':
            screen.blit(YELLOW_SHIP, (100, 150))
        else:
            screen.blit(GREEN_SHIP, (100, 150))
        if p2_skin == 'Green':
            screen.blit(GREEN_SHIP, (100, 500))
        else:
            screen.blit(YELLOW_SHIP, (100, 500))
        screen.blit(triangle, triangle.get_rect(center=triangle_BOX.center))
        screen.blit(triangle2, triangle2.get_rect(center=triangle_BOX2.center))
        screen.blit(triangle3, triangle3.get_rect(center=triangle_BOX3.center))
        screen.blit(triangle4, triangle4.get_rect(center=triangle_BOX4.center))
        p1_text = font.render('Player 1 (Hold LeftShift to Burst)' if LANGUAGE == 'ENGLISH' else
                              'Người chơi 1 (Giữ Shift trái để chạy nhanh)', True,
                              (255, 255, 255) if toggle_dark_mode else (0, 0, 0))
        p2_text = font.render(
            'Player 2 (Hold RightCTRL to Burst)' if LANGUAGE == 'ENGLISH' else 'Người chơi 2 (Giữ CTRL phải để chạy nhanh',
            True,
            (255, 255, 255) if toggle_dark_mode else (0, 0, 0))
        perk_text = font.render('Perks' if LANGUAGE == 'ENGLISH' else 'Kĩ năng', True,
                                (255, 255, 255) if toggle_dark_mode else (0, 0, 0))
        py.draw.rect(screen, (0, 0, 0), buttons[4])
        py.draw.rect(screen, (0, 0, 0), buttons[5])
        perk1_text = font.render(perks[current_p1_perk_idx], True, (255, 255, 255) if toggle_dark_mode else (0, 0, 0))
        perk2_text = font.render(perks[current_p2_perk_idx], True, (255, 255, 255) if toggle_dark_mode else (0, 0, 0))
        desc1_text = font.render(perk_desc[current_p1_perk_idx], True, (255, 255, 255) if toggle_dark_mode else (0, 0, 0))
        desc2_text = font.render(perk_desc[current_p2_perk_idx], True, (255, 255, 255) if toggle_dark_mode else (0, 0, 0))
        blit_text_wrapped(
            screen,
            perk_desc[current_p1_perk_idx],
            font,
            (255, 255, 255) if toggle_dark_mode else (0, 0, 0),
            buttons[8].centerx,
            buttons[8].centery,
            400
        )

        blit_text_wrapped(
            screen,
            perk_desc[current_p2_perk_idx],
            font,
            (255, 255, 255) if toggle_dark_mode else (0, 0, 0),
            buttons[9].centerx,
            buttons[9].centery,
            400
        )

        blit_text_wrapped(
            screen,
            'Player 1 (Hold LeftShift to Burst)' if LANGUAGE == 'ENGLISH' else
            'Người chơi 1 (Giữ Shift trái để Burst/Chạy nhanh)',
            font,
            (255, 255, 255) if toggle_dark_mode else (0, 0, 0),
            buttons[13].centerx,
            buttons[13].centery,
            400
        )

        blit_text_wrapped(
            screen,
            'Player 2 (Hold RightCTRL to Burst)' if LANGUAGE == 'ENGLISH'
            else 'Người chơi 2 (Giữ CTRL phải để Burst/Chạy nhanh)',
            font,
            (255, 255, 255) if toggle_dark_mode else (0, 0, 0),
            buttons[14].centerx,
            buttons[14].centery,
            400
        )

        screen.blit(perk1_text, perk1_text.get_rect(center=buttons[6].center))
        screen.blit(perk2_text, perk2_text.get_rect(center=buttons[7].center))
        screen.blit(perk_text, perk_text.get_rect(center=buttons[10].center))
        screen.blit(perk_text, perk_text.get_rect(center=buttons[11].center))

        # Display Surface
        screen.blit(triangle_SURFACE, triangle.get_rect(center=triangle_BOX.center))
        screen.blit(triangle_SURFACE2, triangle2.get_rect(center=triangle_BOX2.center))
        screen.blit(triangle_SURFACE3, triangle3.get_rect(center=triangle_BOX3.center))
        screen.blit(triangle_SURFACE4, triangle4.get_rect(center=triangle_BOX4.center))
        display()

    # ===== IN GAME =====
    elif state == 'BASE':
        screen.fill(BG_COLOR)
        if not timestopping2:
            x_wave1 -= speed_for_player1 * dt_scale
            player1_ball_x += speed_for_player1 * dt_scale / 100
            distance_to_finish_line1 += speed_for_player1 * dt_scale
        if not timestopping:
            player2_ball_x += speed_for_player2 * dt_scale / 100
            x_wave2 -= speed_for_player2 * dt_scale
            distance_to_finish_line2 += speed_for_player2 * dt_scale
        if not timestopping and not timestopping2:
            x_bg -= 1
        if distance_to_finish_line1 >= finish_line_base_x:
            winner_text = WINNER_FONT.render('PLAYER 1 WINS!', True, (255, 255, 0))
            state = 'END'
            if toggle_fireworks:
                firework_spawner(int(firework_slider.value))
            WIN_sfx.play(0)
        elif distance_to_finish_line2 >= finish_line_base_x:
            winner_text = WINNER_FONT.render('PLAYER 2 WINS!', True, (0, 100, 0))
            state = 'END'
            if toggle_fireworks:
                firework_spawner(int(firework_slider.value))
            WIN_sfx.play(0)
        if energy_ball1_is_visible:
            if not timestopping2:
                x_energy_ball1 -= speed_for_player1 * dt_scale
                if x_energy_ball1 < -480:
                    x_energy_ball1 = 900
                    y_energy_ball1 = random.randint(130, 350)
        if energy_ball2_is_visible:
            if not timestopping:
                x_energy_ball2 -= speed_for_player2 * dt_scale
                if x_energy_ball2 < -480:
                    x_energy_ball2 = 900
                    y_energy_ball2 = random.randint(430, 620)
        if not energy_ball1_is_visible and py.time.get_ticks() - energy_ball_timer1 >= energy_ball_respawn_time:
            while not timestopping2:
                x_energy_ball1 = 900
                y_energy_ball1 = random.randint(130, 350)
                ball_rect = ENERGY_BALL.get_rect(topleft=(x_energy_ball1, y_energy_ball1))
                collision = False
                for rock in rocks:
                    rock_rect = ROCK_IMG.get_rect(topleft=(rock[0], rock[1]))
                    if ball_rect.colliderect(rock_rect):
                        collision = True
                        break
                if not collision:
                    energy_ball1_is_visible = True
                    break
        if not energy_ball2_is_visible and py.time.get_ticks() - energy_ball_timer2 >= energy_ball_respawn_time:
            while not timestopping:
                x_energy_ball2 = 900
                y_energy_ball2 = random.randint(430, 620)
                ball_rect = ENERGY_BALL.get_rect(topleft=(x_energy_ball2, y_energy_ball2))
                collision = False
                for rock in rocks:
                    rock_rect = ROCK_IMG.get_rect(topleft=(rock[0], rock[1]))
                    if ball_rect.colliderect(rock_rect):
                        collision = True
                        break
                if not collision:
                    energy_ball2_is_visible = True
                    break

        if x_bg < -1022:
            x_bg = 0
        if x_wave1 < -1022:
            x_wave1 = 0
        if x_wave2 < -1022:
            x_wave2 = 0
        KEYS = py.key.get_pressed()

        # ===== PLAYER 1 FULL CONTROL =====
        if not timestopping2:
            if KEYS[py.K_w] and y_player1 > 110:
                y_player1 -= 5
            if KEYS[py.K_s] and y_player1 < 350:
                y_player1 += 5
            # Player 1 Burst Ability (LSHIFT key)
            if KEYS[py.K_LSHIFT] and not flashstepping:
                if energy_player1 > 0:
                    if backend_perks[current_p1_perk_idx] == 'More Energy':
                        energy_player1 -= 0.075
                    else:
                        energy_player1 -= 0.2
                    if speed_for_player1 >= normal_speed_for_player1:  # If speed is not below
                        if backend_perks[current_p1_perk_idx] == 'Faster Burst':  # Extra Speed Boost
                            speed_for_player1 = min(21, speed_for_player1 + 0.8)
                        else:
                            speed_for_player1 = min(13, speed_for_player1 + 0.1)
                    else:
                        if backend_perks[current_p1_perk_idx] == 'Faster Burst':  # Extra Speed Boost
                            speed_for_player1 = min(normal_speed_for_player1, speed_for_player1 + 0.8)  # x8 Recovery
                        else:
                            speed_for_player1 = min(normal_speed_for_player1, speed_for_player1 + 0.1)
                else:  # Out of Energy
                    if speed_for_player1 > normal_speed_for_player1 and not ('Speeds' in backend_perks[current_p1_perk_idx]):
                        speed_for_player1 = max(normal_speed_for_player1, speed_for_player1 - 0.1)
                    elif speed_for_player1 < normal_speed_for_player1:
                        if 'Passive' in backend_perks[current_p1_perk_idx]:
                            speed_for_player1 = min(normal_speed_for_player1, speed_for_player1 + 0.05)
                        else:
                            speed_for_player1 = min(normal_speed_for_player1, speed_for_player1 + 0.025)
            else:  # Not Bursting
                if speed_for_player1 > normal_speed_for_player1 and not ('Speeds' in backend_perks[current_p1_perk_idx]):
                    speed_for_player1 = max(normal_speed_for_player1, speed_for_player1 - 0.1)
                elif speed_for_player1 < normal_speed_for_player1:
                    if 'Passive' in backend_perks[current_p1_perk_idx]:
                        speed_for_player1 = min(normal_speed_for_player1, speed_for_player1 + 0.05)
                    elif 'Test' in backend_perks[current_p1_perk_idx]:
                        speed_for_player1 = min(normal_speed_for_player1, speed_for_player1 + 10)
                    else:
                        speed_for_player1 = min(normal_speed_for_player1, speed_for_player1 + 0.025)
            # SPECIAL ABILITY (FLASH STEP / TIMESTOP)
            if KEYS[py.K_c]:
                if 'Flash' in backend_perks[current_p1_perk_idx]:
                    flashstepping, flashstep_start, last_flashstep, flashstep_pack = pk.try_activate_ability(
                        flashstepping, flashstep_start, last_flashstep, flashstep_pack, py.time.get_ticks()
                    )
                elif 'Time' in backend_perks[current_p1_perk_idx]:
                    timestopping, ts_start, last_ts, timestop_pack = pk.try_activate_ability(
                        timestopping, ts_start, last_ts, timestop_pack, py.time.get_ticks()
                    )

            if timestopping:
                current_time3 = py.time.get_ticks()
                TS_SURFACE.fill((0, 0, 0))
                TS_SURFACE.set_alpha(100)
                speed_for_player1 = min(20, speed_for_player1 + 1)
                speed_for_player2 = normal_speed_for_player2
                if current_time3 - ts_start >= timestop_pack[1]:
                    timestopping = False
            else:
                TS_SURFACE.set_alpha(0)
            if flashstepping:
                current_time = py.time.get_ticks()
                speed_for_player1 = min(25, speed_for_player1 + 1)
                if current_time - flashstep_start >= flashstep_pack[1]:
                    flashstepping = False  # hết duration
        # ===== PLAYER 2 FULL CONTROL =====
        if not timestopping:
            if KEYS[py.K_UP] and y_player2 > 380:
                y_player2 -= 5
            if KEYS[py.K_DOWN] and y_player2 < 610:
                y_player2 += 5
            if KEYS[py.K_RCTRL] and not flashstepping2:
                if energy_player2 > 0:  # While Bursting
                    if 'Energy' in backend_perks[current_p2_perk_idx]:
                        energy_player2 -= 0.075
                    else:
                        energy_player2 -= 0.2
                    if 'Burst' in backend_perks[current_p2_perk_idx]:
                        speed_for_player2 = min(21, speed_for_player2 + 0.8)  # Max speed capped at 21, 8x faster windup
                    else:
                        speed_for_player2 = min(13, speed_for_player2 + 0.1)  # Max speed capped at 13, normal windup
                else:  # If out of energy, but still holding ability keybind
                    if speed_for_player2 > normal_speed_for_player2 and not ('Speeds' in backend_perks[current_p2_perk_idx]):
                        speed_for_player2 = max(normal_speed_for_player2, speed_for_player2 - 0.1)
                    elif speed_for_player2 < normal_speed_for_player2:
                        if 'Passive' in backend_perks[current_p2_perk_idx]:
                            speed_for_player2 = min(normal_speed_for_player2, speed_for_player2 + 0.05)
                        else:
                            speed_for_player2 = min(normal_speed_for_player2, speed_for_player2 + 0.025)
            else:  # If not holding ability key (Handle the same as out of energy)
                if speed_for_player2 > normal_speed_for_player2 and not ('Speeds' in backend_perks[current_p2_perk_idx]):
                    speed_for_player2 = max(normal_speed_for_player2, speed_for_player2 - 0.1)
                elif speed_for_player2 < normal_speed_for_player2:
                    if 'Passive' in backend_perks[current_p2_perk_idx]:
                        speed_for_player2 = min(normal_speed_for_player2, speed_for_player2 + 0.05)
                    else:
                        speed_for_player2 = min(normal_speed_for_player2, speed_for_player2 + 0.025)

            # ===== FLASH STEP + TIME-STOP =====
            if KEYS[py.K_BACKSLASH]:
                if 'Flash' in backend_perks[current_p2_perk_idx]:
                    flashstepping2, flashstep_start2, last_flashstep2, flashstep_pack2 = pk.try_activate_ability(
                        flashstepping2, flashstep_start2, last_flashstep2, flashstep_pack2, py.time.get_ticks()
                    )
                elif 'Time' in backend_perks[current_p2_perk_idx]:
                    timestopping2, ts_start2, last_ts2, timestop_pack2 = pk.try_activate_ability(
                        timestopping2, ts_start2, last_ts2, timestop_pack2, py.time.get_ticks()
                    )
            if flashstepping2:
                current_time2 = py.time.get_ticks()
                speed_for_player2 = min(25, speed_for_player2 + 1)
                if current_time2 - flashstep_start2 >= flashstep_pack2[1]:
                    flashstepping2 = False  # hết duration
            if timestopping2:
                current_time4 = py.time.get_ticks()
                TS_SURFACE.fill((0, 0, 0))
                TS_SURFACE.set_alpha(100)
                speed_for_player2 = min(20, speed_for_player2 + 1)
                speed_for_player1 = normal_speed_for_player1
                if current_time4 - ts_start2 >= timestop_pack2[1]:
                    timestopping2 = False
            else:
                TS_SURFACE.set_alpha(0)
        if 'Dark' in backend_perks[current_p1_perk_idx]:
            current_time5 = py.time.get_ticks()
            if current_time5 - last_create_rocks >= 10000 and ability_counts < 3:
                create_rocks_start = current_time5
                last_create_rocks = current_time5
                spawn_rock(2, 2)
                ability_counts += 1
                print('Created rocks using dark magic!')

        if 'Dark' in backend_perks[current_p2_perk_idx]:
            current_time6 = py.time.get_ticks()
            if current_time6 - last_create_rocks2 >= 10000 and ability_counts2 < 3:
                create_rocks_start2 = current_time6
                last_create_rocks2 = current_time6
                spawn_rock(2, 1)
                ability_counts2 += 1
                print('Created rocks using dark magic!')

        # ===== SPEEDSTER PERK (Player 1) =====
        if 'Speeds' in backend_perks[current_p1_perk_idx]:
            if normal_speed_for_player1 <= speed_for_player1 * dt_scale < 20:
                speed_for_player1 = min(20, speed_for_player1 + 0.05)  # tăng từ từ

        # ===== SPEEDSTER PERK (Player 2) =====
        if 'Speeds' in backend_perks[current_p2_perk_idx]:
            if normal_speed_for_player2 <= speed_for_player2 * dt_scale < 20:
                speed_for_player2 = min(20, speed_for_player2 + 0.05)
        screen.blit(BACKGROUND, (x_bg, 0))
        screen.blit(BARRIER, (0, 0))
        screen.blit(PROGRESS_BAR, (250, 0))
        display_plr()
        screen.blit(WAVE, (x_wave1, 130))
        screen.blit(WAVE, (x_wave2, 430))
        if LANGUAGE == 'ENGLISH':
            screen.blit(SETTING_EN, (-35, -25))
        else:
            screen.blit(SETTING_VI, (-35, -25))
        if energy_ball1_is_visible:
            screen.blit(ENERGY_BALL, (x_energy_ball1, y_energy_ball1))
        if energy_ball2_is_visible:
            screen.blit(ENERGY_BALL, (x_energy_ball2, y_energy_ball2))
        if toggle_visible_collision:
            p1_highlight = YELLOW_SHIP_G.get_bounding_rect(1)
            p2_highlight = GREEN_SHIP_G.get_bounding_rect(1)
            py.draw.rect(screen, (255, 255, 0) if p1_skin == 'Yellow' else (0, 100, 0),
                         p1_highlight.move(0, y_player1), 2)
            py.draw.rect(screen, (0, 100, 0) if p2_skin == 'Green' else (255, 255, 0),
                         p2_highlight.move(0, y_player2), 2)
        check_collision()
        finish_screen_x_1 = finish_line_base_x - distance_to_finish_line1
        finish_screen_x_2 = finish_line_base_x - distance_to_finish_line2
        if 0 <= finish_screen_x_1 <= 900:
            screen.blit(FINISH_LINE, (finish_screen_x_1, 135))
        if 0 <= finish_screen_x_2 <= 900:
            screen.blit(FINISH_LINE, (finish_screen_x_2, 400))
        for ROCK in rocks:
            if 130 <= ROCK[1] <= 350:
                if not timestopping2:
                    if -1022 >= ROCK[0] > -10000:
                        ROCK[0] = -10000
                    else:
                        ROCK[0] -= speed_for_player1 * dt_scale
                if ROCK[0] < -10500:
                    while True:
                        new_y = random.randint(130, 350)
                        new_rock_rect = ROCK_IMG.get_rect(topleft=(900, new_y))
                        collision = False
                        for existing_rock in rocks:
                            if existing_rock is not ROCK:
                                existing_rock_rect = ROCK_IMG.get_rect(topleft=(existing_rock[0], existing_rock[1]))
                                if new_rock_rect.colliderect(existing_rock_rect):
                                    collision = True
                                    break
                        if not collision and energy_ball1_is_visible:
                            energy1_rect = ENERGY_BALL.get_rect(topleft=(x_energy_ball1, y_energy_ball1))
                            if new_rock_rect.colliderect(energy1_rect):
                                collision = True
                        if not collision:
                            ROCK[0] = 900
                            ROCK[1] = new_y
                            break
            elif 430 <= ROCK[1] <= 620:
                if not timestopping:
                    if -1022 >= ROCK[0] > -10000:
                        ROCK[0] = -10000
                    else:
                        ROCK[0] -= speed_for_player2 * dt_scale
                if ROCK[0] < -10500:
                    while True:
                        new_y = random.randint(430, 620)
                        new_rock_rect = ROCK_IMG.get_rect(topleft=(900, new_y))
                        collision = False
                        for existing_rock in rocks:
                            if existing_rock is not ROCK:
                                existing_rock_rect = ROCK_IMG.get_rect(topleft=(existing_rock[0], existing_rock[1]))
                                if new_rock_rect.colliderect(existing_rock_rect):
                                    collision = True
                                    break
                        if not collision and energy_ball2_is_visible:
                            energy2_rect = ENERGY_BALL.get_rect(topleft=(x_energy_ball2, y_energy_ball2))
                            if new_rock_rect.colliderect(energy2_rect):
                                collision = True
                        if not collision:
                            ROCK[0] = 900
                            ROCK[1] = new_y
                            break
            screen.blit(ROCK_IMG, (ROCK[0], ROCK[1]))
        if toggle_display_speed:
            DISP_SPD1 = round(speed_for_player1, 2)
            if DISP_SPD1 == int(DISP_SPD1):
                DISP_SPD1 = str(int(DISP_SPD1))  # "6"
            else:
                DISP_SPD1 = f"{DISP_SPD1:.2f}"  # "6.25"
            DISP_SPD2 = round(speed_for_player2, 2)
            if DISP_SPD2 == int(DISP_SPD2):
                DISP_SPD2 = str(int(DISP_SPD2))
            else:
                DISP_SPD2 = f'{DISP_SPD2:.2f}'
            spd_render1 = font.render(f'Speed: {DISP_SPD1}' if LANGUAGE == 'ENGLISH' else f'Tốc độ: {DISP_SPD1}',
                                      True, (0, 0, 0))
            spd_render2 = font.render(f'Speed: {DISP_SPD2}' if LANGUAGE == 'ENGLISH' else f'Tốc độ: {DISP_SPD2}',
                                      True, (0, 0, 0))
            screen.blit(spd_render1, (0, y_player1 + 50))
            screen.blit(spd_render2, (0, y_player2 + 50))
        # Player 1
        if 'Flash' in backend_perks[current_p1_perk_idx]:
            perk_text1 = font.render(
                f'Uses: {flashstep_pack[0]}' if LANGUAGE == 'ENGLISH' else f'Lượt dùng: {flashstep_pack[0]}',
                True, (0, 0, 0)
            )
            screen.blit(perk_text1, (0, y_player1 - 50))

        if 'Time' in backend_perks[current_p1_perk_idx]:
            perk_text1 = font.render(
                f'Uses: {timestop_pack[0]}' if LANGUAGE == 'ENGLISH' else f'Lượt dùng: {timestop_pack[0]}',
                True, (0, 0, 0)
            )
            screen.blit(perk_text1, (0, y_player1 - 50))

        # Player 2
        if 'Flash' in backend_perks[current_p2_perk_idx]:
            perk_text2 = font.render(
                f'Uses: {flashstep_pack2[0]}' if LANGUAGE == 'ENGLISH' else f'Lượt dùng: {flashstep_pack2[0]}',
                True, (0, 0, 0)
            )
            screen.blit(perk_text2, (0, y_player2 - 50))

        if 'Time' in backend_perks[current_p2_perk_idx]:
            perk_text2 = font.render(
                f'Uses: {timestop_pack2[0]}' if LANGUAGE == 'ENGLISH' else f'Lượt dùng: {timestop_pack2[0]}',
                True, (0, 0, 0)
            )
            screen.blit(perk_text2, (0, y_player2 - 50))

        draw_energy_bars()
        screen.blit(TS_SURFACE, (0, 0))
        display()

    # ===== END GAME =====
    elif state == 'END':
        screen.blit(BACKGROUND, (x_bg, 0))
        screen.blit(BARRIER, (0, 0))
        screen.blit(YELLOW_SHIP_G, (0, y_player1))
        screen.blit(GREEN_SHIP_G, (0, y_player2))
        screen.blit(PROGRESS_BAR, (250, 0))
        display_plr()

        screen.blit(WAVE, (x_wave1, 130))
        screen.blit(WAVE, (x_wave2, 430))
        for ROCK in rocks:
            screen.blit(ROCK_IMG, (ROCK[0], ROCK[1]))
        dark_surface = py.Surface((900, 680))
        dark_surface.fill((0, 0, 0))
        dark_surface.set_alpha(int(dark_slider.value))
        screen.blit(dark_surface, (0, 0))
        text_rect = winner_text.get_rect()
        text_rect.centerx = screen.get_width() // 2
        text_rect.y = 200
        screen.blit(winner_text, text_rect)
        if LANGUAGE == 'ENGLISH':
            screen.blit(REPLAY_EN, REPLAY_EN.get_rect(center=REPLAY_BOX.center))
            screen.blit(SETTING_EN, SETTING_EN.get_rect(center=buttons[12].center))
        else:
            screen.blit(REPLAY_VI, REPLAY_VI.get_rect(center=REPLAY_BOX.center))
            screen.blit(SETTING_VI, SETTING_VI.get_rect(center=buttons[12].center))
        if toggle_fps:
            fps_text = font.render(f"FPS: {int(clock.get_fps())}", True, (255, 255, 255))
            screen.blit(fps_text, (0, 350))
        if toggle_fireworks:
            update_fireworks(dt_scale)
        GAME_music.stop()
    py.display.flip()
    clock.tick(9999)
"""
perks = []
perk_desc = []

charges = duration = cooldown = 0


def get_desc(language):
    global perk_desc
    if language == 'ENGLISH':
        perk_desc = [
            'Increase Energy from energy bubble <x2>',  # ✅
            'Reduce slowness effect after taking a rock <-90%>',  # ✅
            'Increase bursting speed <+8>',  # ✅
            'Increase default speed <+3>',  # ✅
            'Move super fast for 3,5s, immune to rocks while flash stepping. <Press C or Backslash>',  # ✅
            'Gain speed after taking a rock <+3>',  #
            'Gain energy after taking a rock, slightly reduce slowness effect',  # ✅
            'Create 2 rocks every 10 seconds (Max 3 times)',  # ✅
            'Freeze enemy for 3 seconds, increase speed and immune to rocks while using. <Press "C" or "/">',  # ✅
            'Faster over time, but hitting a rock will reduce massive amount of speed.',  # ✅
            'Fastest, testing purposes'
        ]
    else:
        perk_desc = [
            'Tăng năng lượng từ bóng năng lượng <x2>',  # [0]
            'Giảm hiệu ứng đi chậm sau khi đâm vào đá <-90%>',  # [1]
            'Tăng thêm tốc độ khi đang burst <+8>',  # [2]
            'Tăng tốc độ mặc định',  # [3]
            'Tăng tốc cực nhanh trong 3,5s, trong thời gian này sẽ miễn nhiễm với đá. <Bấm "C" hoặc "/"',  # [4]
            'Tăng tốc độ sau khi đâm vào đá <+3>',  # [5]
            'Tăng năng lượng sau khi đâm vào đá, giảm nhẹ hiệu ứng đi chậm',  # [6]
            'Tạo 2 đá mỗi 10 giây (Tối đa 3 lượt)',  # [7]
            'Đóng băng đối thủ trong 3 giây, di chuyển nhanh hơn và miễn nhiễm với đá khi đang dùng <Bấm C hoặc />',  # [8]
            'Nhanh hơn qua thời gian, nhưng đâm vào đá sẽ giảm rất nhiều tốc độ.',  # [9]
            'Nhanh nhất, sử dụng cho mục đích thử nghiệm'
        ]
    return perk_desc


def get_manual_use_ability(ability):
    global charges, duration, cooldown
    if ability == 'Absorption':
        charges = 20
    if ability == 'Flash Step':
        charges = 5
        duration = 3500  # ms
        cooldown = 5000
    if ability == 'Timestop':
        charges = 3
        duration = 3000
        cooldown = 7000
    return [charges, duration, cooldown]


def get_perks(language):
    global perks
    if language == 'ENGLISH':
        perks = [
            'More Energy',  # ✅
            'Reduce Slowness',  # ✅
            'Faster Burst',  # ✅
            'Passive Speed',  # ✅
            'Flash Step [x5]',  # ✅
            'Absorption [x20]',  # ✅
            'Rage',  # ✅
            'Dark Magic',  # ✅
            'Timestop [x3]',  # ✅
            'Speedster',  # ✅
            'Test'
        ]
    else:
        perks = [
            'Thêm năng lượng',
            'Giảm đi chậm',
            'Tăng tốc nhanh hơn',
            'Tăng tốc độ',
            'Tốc biến [x5]',
            'Hấp thụ [x20]',
            'Tức giận',
            'Ma thuật đen',
            'Dừng thời gian [x3]',
            'Vua tốc độ',
            'Test'
        ]
    return perks


def try_activate_ability(is_active, start_time, last_time, pack, current_time):
    if current_time - last_time >= pack[2]:  # đủ cooldown
        if not is_active and pack[0] > 0:  # chưa chạy và còn charges
            is_active = True
            start_time = current_time
            last_time = current_time
            pack[0] = max(0, pack[0] - 1)  # trừ charges
    return is_active, start_time, last_time, pack


def get_perks_length():
    temp = get_perks('ENGLISH')
    return len(temp) - 1
"""
