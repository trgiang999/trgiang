import pygame as py
import sys
import random
import json
import perks as pk
CONFIG_FILE = "config.json"

# Storable Data
TOGGLE_MUSIC = True
TOGGLE_SFX = True
TOGGLE_FIREWORKS = False
TOGGLE_BRIGHTNESS = False
TOGGLE_FPS = False
TOGGLE_PLAYER_MARK = False
SPEED_DISPLAY = False
DARK_MODE = True
P1_SKIN = 'Yellow'
P2_SKIN = 'Green'
LANGUAGE = 'T. Việt'
current_p1_perk_idx = 0
current_p2_perk_idx = 0

py.init()
state = 'MENU'
DIFFICULTY = 'MEDIUM'

# SCREEN SETUP
screen = py.display.set_mode((900, 680))
GAME_ICON = py.image.load('Resources/Yellow.png')
py.display.set_caption('Dragon Boat Race')
py.display.set_icon(GAME_ICON)

# IN GAME RESOURCES
BACKGROUND = py.image.load('Resources/HoTay.jpg')
BARRIER = py.image.load('Resources/Phao.png')
WAVE = py.image.load('Resources/water.png')
ROCK_IMG = py.transform.scale(py.image.load('Resources/rocks.svg'), (60, 30))
YELLOW_SHIP_G = py.transform.scale(GAME_ICON, (120, 50))
GREEN_SHIP_G = py.transform.scale(py.image.load('Resources/Green.png'), (120, 50))
ENERGY_BALL = py.transform.scale(py.image.load('Resources/NangLuong.png'), (40, 40))
FIREWORK_IMG = py.image.load('Resources/firework_combined.png')
PROGRESS_BAR = py.transform.scale(py.image.load('Resources/bar.png'), (400, 50))
YELLOW_BALL = py.transform.scale(py.image.load('Resources/yellow_ball.png'), (25, 25))
GREEN_BALL = py.transform.scale(py.image.load('Resources/green_ball.png'), (25, 25))

# SUB SETTINGS RESOURCES
TRASH_BIN = py.transform.scale(py.image.load('Resources/trashbin.png'), (50, 50))
TRIANGLE = py.image.load('Resources/triangle.png')
TRIANGLE2 = py.image.load('Resources/triangle2.png')
TRIANGLE3 = py.image.load('Resources/triangle3.png')
TRIANGLE4 = py.image.load('Resources/triangle4.png')
WINNER = py.font.SysFont('Forte', 80, False)

# SETTING RESOURCES
REPLAY_VI = py.transform.scale(py.image.load('Resources/Setting/play_again.png'), (230, 100)).convert_alpha()
REPLAY_EN = py.transform.scale(py.image.load('Resources/Setting/play_again_en.png'), (230, 100)).convert_alpha()
PLAY_VI = py.transform.scale(py.image.load('Resources/Setting/play.png'), (230, 100)).convert_alpha()
PLAY_EN = py.transform.scale(py.image.load('Resources/Setting/play_en.png'), (230, 100)).convert_alpha()
SETTING_VI = py.transform.scale(py.image.load('Resources/Setting/set_vi.png'), (230, 100)).convert_alpha()
SETTING_EN = py.transform.scale(py.image.load('Resources/Setting/set_en.png'), (230, 100)).convert_alpha()
SETTING_MENU_VI = py.image.load('Resources/Setting/bg_set_vn_no_bg.png')
SETTING_MENU_EN = py.image.load('Resources/Setting/bg_set_en_no_bg.png')
MENU_BG_VI = py.image.load('Resources/bg1_vn_no_bg.png')
MENU_BG_EN = py.image.load('Resources/bg1_en_no_bg.png')
CLOSE = py.transform.scale(py.image.load('Resources/Setting/close.png'), (100, 100))
IDX_1 = py.transform.scale(py.image.load('Resources/Setting/1.png'), (150, 50))
IDX_2 = py.transform.scale(py.image.load('Resources/Setting/2.png'), (150, 50))
IDX_3 = py.transform.scale(py.image.load('Resources/Setting/3.png'), (150, 50))
TOGGLE_ON_VI = py.transform.scale(py.image.load('Resources/Setting/on_vn.png'), (175, 75))
TOGGLE_OFF_VI = py.transform.scale(py.image.load('Resources/Setting/off_vn.png'), (175, 75))
TOGGLE_ON_EN = py.transform.scale(py.image.load('Resources/Setting/on_en.png'), (175, 75))
TOGGLE_OFF_EN = py.transform.scale(py.image.load('Resources/Setting/off_en.png'), (175, 75))

# PLAYER SETTINGS:
YELLOW_SHIP = py.transform.scale(py.image.load('Resources/Yellow.png'), (200, 80))
GREEN_SHIP = py.transform.scale(py.image.load('Resources/Green.png'), (200, 80))

# BOUNDING BOX
PLAY_BOX = py.Rect(220, 405, 170, 50)
SETTING_BOX = py.Rect(520, 405, 170, 50)
REPLAY_BOX = py.Rect(350, 350, 170, 50)
CLOSE_BOX = py.Rect(850, 0, 50, 55)
TRASH_BOX = py.Rect(600, 400, 50, 50)
TRIANGLE_BOX = py.Rect(350, 170, 50, 40)
TRIANGLE_BOX2 = py.Rect(350, 520, 50, 40)
TRIANGLE_BOX3 = py.Rect(800, 100, 50, 40)
TRIANGLE_BOX4 = py.Rect(800, 450, 50, 40)
# TRANSPARENCY/HOVERING EFFECT
PLAY_TRANSPARENCY = 255
SETTING_TRANSPARENCY = 255
REPLAY_TRANSPARENCY = 255
CLOSE_TRANSPARENCY = 255
TRASH_TRANSPARENCY = 255
TRIANGLE_TRANSPARENCY = TRIANGLE2_TRANSPARENCY = TRIANGLE3_TRANSPARENCY = TRIANGLE4_TRANSPARENCY = 255
# POSITION
ENERGY_PLAYER1 = ENERGY_PLAYER2 = 0
X_BG = 0
Y_1 = 250
Y_2 = 500
X_WAVE_1 = X_WAVE_2 = 0
SPEED_1 = SPEED_2 = 5
NORMAL_SPEED1 = NORMAL_SPEED2 = 5
ROCKS = []
FIREWORKS = []
P1_BALL_X = P2_BALL_X = 250
COUNT = 0

# ENERGY BALL'S CONFIGURATION
X_POWER_1 = X_POWER_2 = 900
Y_POWER_1 = random.randint(130, 350)
Y_POWER_2 = random.randint(430, 620)
ENERGY1_IS_VISIBLE = True
ENERGY2_IS_VISIBLE = True
ENERGY_TIMER_1 = 0
ENERGY_TIMER_2 = 0
ENERGY_RESPAWN_TIME = 10000


class Slider:
    def __init__(self, x, y, w, h, value=0.5, min_val=0, max_val=1, knob_radius=14, offset=90, integer=False, count_down=False):
        self.x = x
        self.y = y
        self.w = w
        self.h = h
        self.offset = offset
        self.value = value
        self.min_val = min_val
        self.max_val = max_val
        self.knob_radius = knob_radius
        self.dragging = False
        self.integer = integer
        self.count_down = count_down

    def handle_event(self, event):
        if event.type == py.MOUSEBUTTONDOWN and event.button == 1:
            mouse_x, mouse_y = event.pos
            knob_x = self.x + (self.value - self.min_val) / (
                    self.max_val - self.min_val) * self.w  # Tính vị trí x nút trượt
            if (mouse_x - knob_x) ** 2 + (
                    mouse_y - self.y) ** 2 <= self.knob_radius ** 2:  # Dùng công thức tính tọa độ của chuột có nằm trong bán kính của knob không
                self.dragging = True
            elif self.x <= mouse_x <= self.x + self.w and (self.y - self.h // 2) <= mouse_y <= (
                    self.y + self.h // 2):  # Khi bấm chuột trong thanh truợt
                self.value = (mouse_x - self.x) / self.w * (
                        self.max_val - self.min_val) + self.min_val  # Tính giá trị từ vị trí chuột
                self.value = max(self.min_val, min(self.max_val,
                                                   self.value))  # Giới hạn lại giá trị để đảm bảo không bé hơn min_val và không lớn hơn max_val (Clamp)
                self.dragging = True

        elif event.type == py.MOUSEBUTTONUP and event.button == 1:
            self.dragging = False  # Ngừng kéo knob

        elif event.type == py.MOUSEMOTION and self.dragging:  # Xử lí khi kéo knob
            mouse_x, _ = event.pos  # Lấy x của chuột
            mouse_x = max(self.x, min(self.x + self.w, mouse_x))  # Giới hạn mouse_x để knob không bị trượt ra ngoài
            self.value = (mouse_x - self.x) / self.w * (
                    self.max_val - self.min_val) + self.min_val  # Tính giá trị từ vị trí của chuột y như ở trên
            self.value = max(self.min_val, min(self.max_val, self.value))  # Clamp

    def draw(self, surface, font, label, dark_mode=False):
        track_rect = py.Rect(self.x, self.y - self.h // 2, self.w, self.h)
        py.draw.rect(surface, (180, 180, 180), track_rect, border_radius=10)
        ratio = (self.value - self.min_val) / (self.max_val - self.min_val)
        down_ratio = (self.max_val - self.value) / (self.max_val - self.min_val)

        fill_width = self.w * ratio
        fill_rect = py.Rect(self.x, self.y - self.h // 2, fill_width, self.h)
        py.draw.rect(surface, (50, 120, 255), fill_rect, border_radius=10)
        knob_x = self.x + ratio * self.w
        knob_color = (100, 150, 255) if self.dragging else (50, 120, 255)
        py.draw.circle(surface, knob_color, (int(knob_x), self.y), self.knob_radius)
        if self.count_down:
            display_percent = int(down_ratio * 100)
        else:
            display_percent = int(ratio * 100)
        if not self.integer:  # Cho thêm 1 lựa chọn là sử dụng % hay giá trị thô
            text_surface = font.render(f"{label}: {display_percent}%", True,
                                       (255, 255, 255) if dark_mode else (0, 0, 0))
        else:
            text_surface = font.render(f"{label}: {int(self.value)}", True, (255, 255, 255) if dark_mode else (0, 0, 0))
        text_rect = text_surface.get_rect()
        text_rect.centerx = self.x + self.w / 2
        text_rect.y = self.y + self.offset
        surface.blit(text_surface, text_rect)


class InputBox:
    def __init__(self, x, y, w, h, text='', min_val=0, max_val=100, multiplier=1.0, num_val=True, lost_focus=False):
        self.rect = py.Rect(x, y, w, h)
        self.color_inactive = (100, 100, 100)
        self.color_active = (0, 0, 255)
        self.BG_COLOR = self.color_inactive
        self.text = text
        self.font = py.font.SysFont('Arial', 25)
        self.active = False
        self.min_val = min_val
        self.max_val = max_val
        self.multiplier = multiplier
        self.num_val = num_val
        self.lost_focus = lost_focus

    def _sync_live(self, slider):
        if not self.num_val:
            return  # Nếu là chế độ text (num_val=False) thì không cần đồng bộ slider
        if self.text == '':  # Nếu không có gì trong input
            if slider:  # Nếu đang kéo slider
                slider.value = (self.min_val / self.max_val) * self.multiplier  # Đồng bộ hóa giá trị của slider
            return  # Trả về kết quả và ngừng xử lí
        try:
            val = int(self.text)  # Thử đặt giá trị thành số nguyên của string được hiện trên màn hình
        except ValueError:
            return  # Ngừng xử lí nếu giá trị quá lớn hoặc không đúng loại giá trị
        val = max(self.min_val, min(self.max_val, val))  # Clamp
        if slider:
            slider.value = (val / self.max_val) * self.multiplier

    def handle_event(self, event, slider=None):
        if event.type == py.MOUSEBUTTONDOWN and event.button == 1:
            self.active = self.rect.collidepoint(
                event.pos)  # Đặt giá trị của InputBox là True hoặc False, tùy thuộc nếu nhấn chuột có nhấn vào InputBox hay không
            if self.active and self.lost_focus:
                self.text = ''
            self.BG_COLOR = self.color_active if self.active else self.color_inactive  # Chỉnh sửa màu viền của InputBox tùy vào trạng thái
        if not self.active:  # Nếu không được chọn thì thoát hàm có chủ đích. (Nếu self.active ở trên là True thì sẽ không thỏa mãn điều kiện, dẫn đến tiếp tục xử lí.)
            return
        if event.type == py.KEYDOWN:
            if event.key == py.K_BACKSPACE:  # Xóa
                self.text = self.text[:-1]
                if self.num_val:
                    self._sync_live(slider)  # Đồng bộ hóa với slider
                return
            if event.key == py.K_DELETE:  # Xóa toàn bộ
                self.text = ''
                if self.num_val:
                    self._sync_live(slider)
                return
            if event.key == py.K_RETURN:  # Enter
                self.active = False
                self.BG_COLOR = self.color_inactive
                return

            # Xử lí nhập liệu phụ thuộc vào num_val
            if self.num_val:  # ----> Nếu num_val=True thì chỉ cho nhập số
                if event.unicode and event.unicode.isdigit():  # Xử lí xem đầu vào có phải là chữ số không
                    if len(self.text) < len(
                            str(self.max_val)):  # Nếu độ dài giá trị bên trong vẫn chưa bằng giá trị tối đa
                        self.text += event.unicode  # Thêm kí tự
                        try:
                            if int(self.text) > self.max_val:  # Nếu lớn hơn giá trị tối đa
                                self.text = str(self.max_val)  # Đặt về giá trị tối đa
                        except ValueError:  # Nếu giá trị quá lớn thì bỏ qua
                            pass
                        self._sync_live(slider)  # Sync
            else:  # Cho nhập bất kì kí tự nào
                if event.unicode:
                    if len(self.text) < 16:
                        self.text += event.unicode  # Không giới hạn, thêm bất kỳ kí tự nào người dùng nhập

    def draw(self, surface):
        py.draw.rect(surface, (255, 255, 255), self.rect, border_radius=8)
        py.draw.rect(surface, self.BG_COLOR, self.rect, 2, border_radius=8)
        txt_surface = self.font.render(
            self.text if self.text != '' else (str(self.min_val) if self.num_val else ''),
            # Nếu là số thì hiển thị min_val mặc định, còn text thì để trống
            True, (0, 0, 0))
        text_rect = txt_surface.get_rect(center=self.rect.center)
        surface.blit(txt_surface, text_rect)


class Dropdown:
    def __init__(self, x, y, w, h, options, default_value, font, max_visible_items=5, extension=True):
        self.rect = py.Rect(x, y, w, h)
        self.options = options
        self.max_visible_items = max_visible_items  # Maximum number of visible items
        self.scroll_offset = 0  # Current scroll position (in items)
        if isinstance(default_value, str):
            if default_value in self.options:
                self.selected_index = self.options.index(
                    default_value)  # Nếu lựa chọn mặc định đã có sẵn trong ds thì lấy index
            else:
                self.selected_index = 0  # Nếu ko thì lấy gtr đầu tiên
        else:
            if 0 <= default_value < len(self.options):
                self.selected_index = default_value  # Nếu list đủ dài để lấy giá trị mặc định là số nguyên thì lấy luôn
            else:
                self.selected_index = 0  # Không thì lấy gtr đầu tiên như ở trên  <<Cách xử lí này còn gọi là Fallback>>

        self.is_open = False
        self.font = font
        self.hover_index = -1
        self.extension = extension

    def handle_event(self, event):
        if event.type == py.MOUSEBUTTONDOWN and event.button == 1:  # Nếu nhấn chuột trái
            mouse_pos = event.pos  # Lấy tọa độ chuột
            if self.rect.collidepoint(mouse_pos):  # Nếu bấm vào dropdown
                play_sfx()
                self.is_open = not self.is_open
            elif self.is_open:  # Nếu đang mở thì:
                # Chỉ kiểm tra trong vùng hiển thị (scroll_offset → scroll_offset + max_visible_items)
                for i in range(self.scroll_offset, min(self.scroll_offset + self.max_visible_items, len(self.options))):
                    option_rect = py.Rect(
                        self.rect.x,
                        self.rect.y + (i - self.scroll_offset + 1) * self.rect.h,
                        self.rect.w,
                        self.rect.h
                    )
                    if option_rect.collidepoint(mouse_pos):  # Nếu bấm vào 1 lựa chọn
                        play_sfx()
                        self.selected_index = i  # Đặt index thành i (i là index của lựa chọn được chọn)
                        self.is_open = False  # Đóng dropdown
                        break
                else:
                    self.is_open = False  # Nếu click ngoài thì đóng

        elif event.type == py.MOUSEWHEEL and self.is_open:
            # Xử lý scroll bằng chuột
            if len(self.options) > self.max_visible_items:
                self.scroll_offset = max(0,
                                         min(self.scroll_offset - event.y, len(self.options) - self.max_visible_items))
        self.update_hover(py.mouse.get_pos())

    def update_hover(self, mouse_pos):
        if self.is_open:  # Nếu dropdown đang mở thì mới kiểm tra
            self.hover_index = -1  # Không di vào gì
            # Chỉ xử lí những thứ đang hiện trên mh
            for i in range(self.scroll_offset, min(self.scroll_offset + self.max_visible_items, len(self.options))):
                # Xác định rect của các lựa chọn đang hiện
                option_rect = py.Rect(
                    self.rect.x,
                    self.rect.y + (i - self.scroll_offset + 1) * self.rect.h,
                    self.rect.w,
                    self.rect.h
                )
                if option_rect.collidepoint(mouse_pos):  # Nếu di chuột vào
                    self.hover_index = i  # Đặt luôn hover_index thành i (Tức lựa chọn được di vào)
                    break  # Ngừng kt khi item đã được hover rồi

    def draw(self, surface):
        BG_COLOR = (45, 45, 45)
        BORDER_COLOR = (180, 180, 180)
        TEXT_COLOR = (255, 255, 255)
        ARROW_COLOR = (220, 220, 220)
        HOVER_COLOR = (65, 105, 225)
        ITEM_BG_COLOR = (55, 55, 55)
        py.draw.rect(surface, BG_COLOR, self.rect, border_radius=6)
        py.draw.rect(surface, BORDER_COLOR, self.rect, 2, border_radius=6)
        if self.extension:
            selected_text = shorten_text(self.options[self.selected_index])
        else:
            selected_text = self.options[self.selected_index]

        text_surface = self.font.render(selected_text, True, TEXT_COLOR)
        text_rect = text_surface.get_rect(x=self.rect.x + 10, centery=self.rect.centery)
        surface.blit(text_surface, text_rect)
        center_x = self.rect.right - 15
        center_y = self.rect.centery
        if self.is_open:
            points = [(center_x - 6, center_y - 3), (center_x + 6, center_y - 3),
                      (center_x, center_y + 4)]  # Lấy 3 cạnh của TGC
        else:
            points = [(center_x - 6, center_y + 3), (center_x + 6, center_y + 3),
                      (center_x, center_y - 4)]  # Lấy 3 cạnh của TGC
        py.draw.polygon(surface, ARROW_COLOR, points)  # Vẽ hình TGC
        if self.is_open:
            # Lặp qua danh sách options nhưng chỉ lấy những option trong khoảng cho phép (tùy theo scroll_offset và số item hiển thị tối đa)
            for i in range(self.scroll_offset, min(self.scroll_offset + self.max_visible_items, len(self.options))):
                # Rect của lựa chọn (tính lại vị trí Y dựa trên i - self.scroll_offset để item luôn vẽ đúng vị trí trong khung dropdown)
                option_rect = py.Rect(
                    self.rect.x,
                    self.rect.y + (i - self.scroll_offset + 1) * self.rect.h,
                    # Dời xuống dưới khung chính, trừ scroll_offset để giữ đúng thứ tự hiển thị
                    self.rect.w,
                    self.rect.h
                )
                # Đặt màu nền: nếu đang di chuột vào item thì dùng HOVER_COLOR, ngược lại dùng ITEM_BG_COLOR
                bg_color = HOVER_COLOR if i == self.hover_index else ITEM_BG_COLOR
                py.draw.rect(surface, bg_color, option_rect, border_radius=4)  # Vẽ màu nền
                py.draw.rect(surface, BORDER_COLOR, option_rect, 1, border_radius=4)  # Vẽ outline viền cho option

                # Biến text để vẽ lên (nội dung chính là self.options[i])
                if self.extension:
                    option_text = shorten_text(self.options[i])
                else:
                    option_text = self.options[i]

                text_surface = self.font.render(option_text, True, TEXT_COLOR)

                # Rect của text: đặt text lệch 10px từ trái, và căn giữa theo chiều cao của option_rect
                text_rect = text_surface.get_rect(x=option_rect.x + 10, centery=option_rect.centery)
                surface.blit(text_surface, text_rect)  # Vẽ text lên màn hình


BG_COLOR = (0, 166, 82)
colors = [
    BG_COLOR,  # [0] Default Green
    (51, 255, 51),  # [1] Green
    (51, 255, 255),  # [2] Sky blue
    (255, 0, 0),  # [3] Red
    (255, 255, 0),  # [4] Yellow
    (255, 128, 0),  # [5] Orange
    (255, 255, 255),  # [6] White
    (0, 0, 0),  # [7] Black
    (102, 255, 102),  # [8] Light Green
    (153, 0, 153),  # [9] Purple
    (30, 30, 30),  # [10] Dark
]
rgb_colors = [
    (51, 255, 51),  # Green
    (255, 255, 0),  # Yellow
    (255, 128, 0),  # Orange
    (255, 0, 0),  # Red
    (153, 0, 153),  # Purple
    (51, 255, 255),  # Sky blue
]
# SETTING SLIDER + INPUT
volume_slider = Slider(225, 300, 150, 20, value=0.5, min_val=0, max_val=1, knob_radius=14)
volume_input = InputBox(270, 340, 60, 40, text='50')

# ADV SETTING SLIDER + INPUT
dark_slider = Slider(225, 550, 150, 20, value=0, min_val=0, max_val=170, knob_radius=14, count_down=True)
dark_input = InputBox(270, 590, 60, 40, text='0', min_val=0, max_val=170, multiplier=170)
firework_slider = Slider(430, 550, 150, 20, value=0.1, min_val=0, max_val=50, knob_radius=14, integer=True)
firework_input = InputBox(475, 590, 60, 40, text='10', min_val=0, max_val=50, multiplier=50)
sfx_slider = Slider(620, 550, 150, 20, value=1, min_val=0, max_val=1, knob_radius=14)
sfx_input = InputBox(665, 590, 60, 40, text='100', min_val=0, max_val=100, multiplier=1)

# VISUAL SETTINGS SLIDER + INPUT
red_slider = Slider(100, 100, 250, 20, value=0, min_val=0, max_val=255, knob_radius=14, integer=True, offset=50)
green_slider = Slider(100, 200, 250, 20, value=166, min_val=0, max_val=255, knob_radius=14, integer=True, offset=50)
blue_slider = Slider(100, 300, 250, 20, value=82, min_val=0, max_val=255, knob_radius=14, integer=True, offset=50)
red_input = InputBox(400, 100, 60, 40, text='0', min_val=0, max_val=255, multiplier=255)
green_input = InputBox(400, 200, 60, 40, text='166', min_val=0, max_val=255, multiplier=255)
blue_input = InputBox(400, 300, 60, 40, text='82', min_val=0, max_val=255, multiplier=255)

save_input = InputBox(325, 400, 250, 50, text='', num_val=False, lost_focus=True)
# DROPDOWN CONFIG
font = py.font.SysFont('Arial', 25)
language_dropdown = Dropdown(390, 300, 150, 40, ['ENGLISH', 'T. Việt'], 'ENGLISH', font)
difficulty_dropdown = Dropdown(550, 300, 150, 40, [
                                                                'EASY', 'MEDIUM', 'HARD', 'INSANE', 'EXTREME'
                                                            ], 'MEDIUM', font)
color_dropdown = Dropdown(700, 150, 170, 40, [
                                                        'Default', 'Green', 'Sky blue',
                                                        'Red', 'Yellow', 'Orange', 'White',
                                                        'Black', 'Light green', 'Purple', 'Dark', 'Rainbow',
                                                        'Custom',
                                                    ], 'Default', font, extension=False)
saved_color_dropdown = Dropdown(500, 150, 170, 40, ['Default'], 'Default', font)
previous_color_idx = 0
clock = py.time.Clock()

# SOUNDS
BG_MUSIC = py.mixer.Sound('Resources/nhacnen.mp3')
GAME_MUSIC = py.mixer.Sound('Resources/nhacnen1.mp3')
ENERGY_BALL_SOUND = py.mixer.Sound('Resources/power_sound.wav')
ROCK_SOUND = py.mixer.Sound('Resources/rock_sound.wav')
CLICK_SFX = py.mixer.Sound('Resources/ButtonPlate Click.wav')
WIN_SFX = py.mixer.Sound('Resources/WinSFX.mp3')
BG_MUSIC.play(-1)

# DISTANCE TRACKING
DISTANCE_1 = 0
DISTANCE_2 = 0
FINISH_LINE_WORLD_X = 40000
FINISH_LINE = py.transform.scale(py.image.load('Resources/finish_line.png'), (200, 265))

# PERKS
backend_perks = pk.get_perks('ENGLISH')

# Special Perks for P1
absorption_pack = pk.get_manual_use_ability('Absorption')
timestop_pack = pk.get_manual_use_ability('Timestop')
flashstep_pack = pk.get_manual_use_ability('Flash Step')
# Flash Step
flashstepping = False
last_flashstep = -99999
flashstep_start = 0
# Timestop
timestopping = False
last_ts = -9999
ts_start = 0
# Dark Magic
last_create_rocks = -9999
create_rocks_start = 0
ability_counts = 0
# Special Perks for P2
absorption_pack2 = pk.get_manual_use_ability('Absorption')
timestop_pack2 = pk.get_manual_use_ability('Timestop')
flashstep_pack2 = pk.get_manual_use_ability('Flash Step')
# Flash Step
flashstepping2 = False
last_flashstep2 = -99999
flashstep_start2 = -9999
# Timestop
timestopping2 = False
last_ts2 = 0
ts_start2 = 0
# Dark Magic
last_create_rocks2 = -9999
create_rocks_start2 = 0
ability_counts2 = 0
# Surfaces
ts_surface = py.Surface((900, 680))
triangle_surface = py.Surface((50, 45))
triangle_surface2 = py.Surface((50, 45))
triangle_surface3 = py.Surface((50, 45))
triangle_surface4 = py.Surface((50, 45))
triangle_surface.set_alpha(0)
triangle_surface2.set_alpha(0)
triangle_surface3.set_alpha(0)
triangle_surface4.set_alpha(0)
ts_surface.set_alpha(0)


def save_config(save_list, saved_color_list):
    try:
        config = {
            "TOGGLE_MUSIC": TOGGLE_MUSIC,
            "TOGGLE_SFX": TOGGLE_SFX,
            "TOGGLE_FIREWORKS": TOGGLE_FIREWORKS,
            "TOGGLE_BRIGHTNESS": TOGGLE_BRIGHTNESS,
            "TOGGLE_FPS": TOGGLE_FPS,
            "TOGGLE_PLAYER_MARK": TOGGLE_PLAYER_MARK,
            "SPEED_DISPLAY": SPEED_DISPLAY,
            "P1_SKIN": P1_SKIN,
            "P2_SKIN": P2_SKIN,
            "LANGUAGE": LANGUAGE,
            "save_list": save_list,
            "saved_color_list": [list(c) for c in saved_color_list],
            "P1_PERK": current_p1_perk_idx,
            "P2_PERK": current_p2_perk_idx,
            "COLOR_SELECTED_INDEX": color_dropdown.selected_index,
            "DARK_MODE": DARK_MODE,
            "RED_SLIDER": int(red_slider.value),
            "GREEN_SLIDER": int(green_slider.value),
            "BLUE_SLIDER": int(blue_slider.value),
            "BRIGHTNESS": int(dark_slider.value),
            "VOLUME": volume_slider.value,
            "SFX": sfx_slider.value,
            "FIREWORKS": firework_slider.value,
        }
        with open(CONFIG_FILE, "w", encoding="utf-8") as f:
            json.dump(config, f, indent=4, ensure_ascii=False)
        print("Đã lưu config:", config)
    except Exception as e:
        print("Lỗi khi lưu config:", e)


def load_config():
    try:
        with open(CONFIG_FILE, "r", encoding="utf-8") as f:
            config = json.load(f)
        global TOGGLE_MUSIC, TOGGLE_SFX, TOGGLE_FIREWORKS, TOGGLE_BRIGHTNESS
        global TOGGLE_FPS, TOGGLE_PLAYER_MARK, SPEED_DISPLAY, DARK_MODE
        global P1_SKIN, P2_SKIN, LANGUAGE
        global current_p1_perk_idx, current_p2_perk_idx

        TOGGLE_MUSIC = config.get("TOGGLE_MUSIC", True)
        TOGGLE_SFX = config.get("TOGGLE_SFX", True)
        TOGGLE_FIREWORKS = config.get("TOGGLE_FIREWORKS", True)
        TOGGLE_BRIGHTNESS = config.get("TOGGLE_BRIGHTNESS", False)
        TOGGLE_FPS = config.get("TOGGLE_FPS", True)
        TOGGLE_PLAYER_MARK = config.get("TOGGLE_PLAYER_MARK", True)
        SPEED_DISPLAY = config.get("SPEED_DISPLAY", False)
        DARK_MODE = config.get("DARK_MODE", False)
        P1_SKIN = config.get("P1_SKIN", "Default")
        P2_SKIN = config.get("P2_SKIN", "Default")
        LANGUAGE = config.get("LANGUAGE", "ENGLISH")
        red_slider.value = min(config.get("RED_SLIDER", 30), 255)
        green_slider.value = min(config.get("GREEN_SLIDER", 30), 255)
        blue_slider.value = min(config.get("BLUE_SLIDER", 30), 255)
        dark_slider.value = min(config.get("BRIGHTNESS", 0), 170)
        firework_slider.value = min(config.get("FIREWORKS", 0), 50)
        sfx_slider.value = min(config.get("SFX", .5), .5)
        volume_slider.value = min(config.get("VOLUME", .5), 1)

        # load perks
        current_p1_perk_idx = config.get("P1_PERK", 0)
        current_p2_perk_idx = config.get("P2_PERK", 0)

        save_list = config.get("save_list", []) or ["Default"]
        saved_color_list = [tuple(c) for c in config.get("saved_color_list", [])] or [(0, 166, 82)]

        selected_index = config.get("COLOR_SELECTED_INDEX", 0)
        if 0 <= selected_index < len(color_dropdown.options):
            color_dropdown.selected_index = selected_index
        else:
            color_dropdown.selected_index = 0  # fallback an toàn
        print('Đã load config thành công!')
        return save_list, saved_color_list
    except FileNotFoundError:
        return ["Default"], [(0, 166, 82)]
    except Exception as e:
        print("Lỗi khi load config:", e)
        return ["Default"], [(0, 166, 82)]


def spawn_rock(NUM, TEAM):
    for _ in range(NUM):
        while True:
            if TEAM == 1:
                ROCK_X = random.randint(700, 900)
                ROCK_Y = random.randint(130, 350)
            else:
                ROCK_X = random.randint(700, 900)
                ROCK_Y = random.randint(430, 620)
            new_rock_rect = ROCK_IMG.get_rect(topleft=(ROCK_X, ROCK_Y))
            collision = False
            for existing_rock in ROCKS:
                existing_rock_rect = ROCK_IMG.get_rect(topleft=(existing_rock[0], existing_rock[1]))
                if new_rock_rect.colliderect(existing_rock_rect):
                    collision = True
                    break
            if not collision:
                ROCKS.append([ROCK_X, ROCK_Y])
                break


def check_collision():
    global SPEED_1, SPEED_2
    global X_POWER_1, X_POWER_2, Y_POWER_1, Y_POWER_2
    global ENERGY1_IS_VISIBLE, ENERGY2_IS_VISIBLE, ENERGY_TIMER_1, ENERGY_TIMER_2
    global ENERGY_PLAYER1, ENERGY_PLAYER2
    global flashstepping, flashstepping2
    global timestopping, timestopping2
    global absorption_pack, absorption_pack2
    P1_HITBOX = YELLOW_SHIP_G.get_rect(topleft=(0, Y_1))
    P2_HITBOX = GREEN_SHIP_G.get_rect(topleft=(0, Y_2))
    backend_perks = pk.get_perks('ENGLISH')
    for ROCK in ROCKS:
        ROCK_COLLIDE_BOX = ROCK_IMG.get_rect(topleft=(ROCK[0], ROCK[1]))
        if P1_HITBOX.colliderect(ROCK_COLLIDE_BOX) and (not timestopping and not flashstepping):
            ROCK[0] = -10000
            if TOGGLE_SFX:
                ROCK_SOUND.play(0)
            if 'Speeds' in backend_perks[current_p1_perk_idx]:
                SPEED_1 = -5
            elif backend_perks[current_p1_perk_idx] == 'Reduce Slowness':
                SPEED_1 = max(0.1, SPEED_1 - (4 * .1))
            elif backend_perks[current_p1_perk_idx] == 'Rage':
                ENERGY_PLAYER1 += 8
                SPEED_1 = max(0.1, SPEED_1 - 3)
            elif 'Absorption' in backend_perks[current_p1_perk_idx]:
                if absorption_pack[0] > 0:
                    absorption_pack[0] = max(0, absorption_pack[0] - 1)
                    SPEED_1 = max(40, SPEED_1 + 3)
                    print(f'{absorption_pack[0]} charges left')
                else:  # Out of charges
                    SPEED_1 = max(0.1, SPEED_1 - 4)
            else:
                SPEED_1 = max(0.1, SPEED_1 - 4)
        if P2_HITBOX.colliderect(ROCK_COLLIDE_BOX) and (not timestopping2 and not flashstepping2):
            ROCK[0] = -10000
            if TOGGLE_SFX:
                ROCK_SOUND.play(0)
            if 'Speeds' in backend_perks[current_p2_perk_idx]:
                SPEED_2 = -5
            elif backend_perks[current_p2_perk_idx] == 'Reduce Slowness':
                SPEED_2 = max(0.1, SPEED_2 - (4 * .1))
            elif 'Absorption' in backend_perks[current_p2_perk_idx]:
                if absorption_pack2[0] > 0:
                    absorption_pack2[0] = max(0, absorption_pack2[0] - 1)
                    SPEED_2 = max(35, SPEED_2 + 3)
                    print(f'{absorption_pack2[0]} charges left')
                else:  # Out of charges
                    SPEED_2 = max(0.1, SPEED_1 - 4)
            else:
                if backend_perks[current_p2_perk_idx] == 'Rage':
                    ENERGY_PLAYER2 += 8
                SPEED_2 = max(0.1, SPEED_2 - 4)
    if ENERGY1_IS_VISIBLE:
        BALL_COLLISION_1 = ENERGY_BALL.get_rect(topleft=(X_POWER_1, Y_POWER_1))
        if P1_HITBOX.colliderect(BALL_COLLISION_1):
            if 'Speeds' in backend_perks[current_p1_perk_idx]:
                ENERGY_PLAYER1 += 10
            else:
                ENERGY_PLAYER1 += 25
            ENERGY1_IS_VISIBLE = False
            ENERGY_TIMER_1 = py.time.get_ticks()
            if TOGGLE_SFX:
                ENERGY_BALL_SOUND.play(0)
    if ENERGY2_IS_VISIBLE:
        BALL_COLLISION_2 = ENERGY_BALL.get_rect(topleft=(X_POWER_2, Y_POWER_2))
        if P2_HITBOX.colliderect(BALL_COLLISION_2):
            if 'Speeds' in backend_perks[current_p2_perk_idx]:
                ENERGY_PLAYER2 += 10
            else:
                ENERGY_PLAYER2 += 25
            ENERGY2_IS_VISIBLE = False
            ENERGY_TIMER_2 = py.time.get_ticks()
            if TOGGLE_SFX:
                ENERGY_BALL_SOUND.play(0)


def firework_spawner(NUM):
    for _ in range(NUM):
        X_POSITION = random.randint(200, 700)
        Y_POSITION = random.randint(600, 900)
        FIREWORK_SPEED = random.randint(5, 10)
        MAXIMUM_Y = random.randint(150, 250)
        FIREWORKS.append([X_POSITION, Y_POSITION, FIREWORK_SPEED, MAXIMUM_Y])


def update_fireworks():
    global FIREWORKS
    new_fireworks = []
    for FIREWORK in FIREWORKS:
        FIREWORK[1] -= FIREWORK[2]
        screen.blit(FIREWORK_IMG, (FIREWORK[0], FIREWORK[1]))
        if FIREWORK[1] > FIREWORK[3]:
            new_fireworks.append(FIREWORK)
    FIREWORKS = new_fireworks


WINNER_TEXT = None

BUTTONS = [
    py.Rect(0, 0, 300, 50),  # ADVANCED SETTTINGS [0]
    py.Rect(0, 200, 100, 100),  # Background [1]
    py.Rect(300, 500, 300, 50),  # Save Changes [2]
    py.Rect(0, 400, 100, 100),  # Player's Configuration [3]
    py.Rect(450, 0, 10, 900),  # Vertical Line [4]
    py.Rect(0, 340, 900, 10),  # Horizontal Line [5]
    py.Rect(460, 100, 440, 50),  # Current Perk's Back Layer [6]
    py.Rect(460, 450, 440, 50),  # Current Perk2's Back Layer [7]
    py.Rect(585, 150, 200, 100),  # Perk's Description [8]
    py.Rect(585, 500, 200, 100),  # Perk2's Description [9]
    py.Rect(460, 50, 440, 50),  # Perk Rect [10]
    py.Rect(460, 400, 440, 50),  # Perk2 Rect [11]
    py.Rect(350, 450, 170, 50),  # Setting button in End State [12]
    py.Rect(0, 50, 450, 100),
    py.Rect(0, 400, 450, 100)
]


def reset_game():
    global X_BG, Y_1, Y_2, X_WAVE_1, X_WAVE_2
    global SPEED_1, SPEED_2, ROCKS, FIREWORKS
    global P1_BALL_X, P2_BALL_X
    global X_POWER_1, X_POWER_2, Y_POWER_1, Y_POWER_2
    global ENERGY1_IS_VISIBLE, ENERGY2_IS_VISIBLE
    global ENERGY_TIMER_1, ENERGY_TIMER_2
    global WINNER_TEXT
    global DISTANCE_1, DISTANCE_2
    global ENERGY_PLAYER1, ENERGY_PLAYER2
    global flashstepping, flashstepping2
    global timestopping, timestopping2
    global last_flashstep, last_flashstep2
    global last_ts, last_ts2
    global ts_start, ts_start2
    global flashstep_start, flashstep_start2
    global absorption_pack, absorption_pack2, timestop_pack, timestop_pack2, flashstep_pack, flashstep_pack2
    global ability_counts, ability_counts2, last_create_rocks, last_create_rocks2, create_rocks_start, create_rocks_start2
    # Packages for both players
    absorption_pack = pk.get_manual_use_ability('Absorption')
    timestop_pack = pk.get_manual_use_ability('Timestop')
    flashstep_pack = pk.get_manual_use_ability('Flash Step')

    absorption_pack2 = pk.get_manual_use_ability('Absorption')
    timestop_pack2 = pk.get_manual_use_ability('Timestop')
    flashstep_pack2 = pk.get_manual_use_ability('Flash Step')
    # Special Perks for P1
    timestopping2 = False
    flashstepping2 = False
    last_flashstep2 = -99999
    last_ts2 = -9999
    flashstep_start2 = 0
    ts_start2 = 0
    # Special Perks for P2
    timestopping = False
    flashstepping = False
    last_flashstep = -99999
    last_ts = -9999
    flashstep_start = 0
    ts_start = 0
    # Dark Magic
    last_create_rocks = -9999
    create_rocks_start = 0
    ability_counts = 0
    # Dark Magic for P2
    last_create_rocks2 = -9999
    create_rocks_start2 = 0
    ability_counts2 = 0
    DISTANCE_1 = 0
    DISTANCE_2 = 0
    X_BG = 0
    Y_1 = 250
    Y_2 = 500
    X_WAVE_1 = 0
    X_WAVE_2 = 0
    SPEED_1 = 5
    SPEED_2 = 5
    ENERGY_PLAYER1 = ENERGY_PLAYER2 = 0
    if TOGGLE_MUSIC:
        BG_MUSIC.stop()
        GAME_MUSIC.play(-1)
    ROCKS = []
    FIREWORKS = []
    num_rocks = 0
    if DIFFICULTY == 'EASY' or DIFFICULTY == 'DỄ':
        num_rocks = 1
    elif DIFFICULTY == 'MEDIUM' or DIFFICULTY == 'THƯỜNG':
        num_rocks = 3
    elif DIFFICULTY == 'HARD' or DIFFICULTY == 'KHÓ':
        num_rocks = 5
    elif DIFFICULTY == 'INSANE' or DIFFICULTY == 'ĐIÊN LOẠN':
        num_rocks = 7
    elif DIFFICULTY == 'EXTREME' or DIFFICULTY == 'CỰC KHÓ':
        num_rocks = 9
    spawn_rock(num_rocks, 1)
    spawn_rock(num_rocks, 2)
    P1_BALL_X = 250
    P2_BALL_X = 250
    X_POWER_1 = 900
    X_POWER_2 = 900
    Y_POWER_1 = random.randint(130, 350)
    Y_POWER_2 = random.randint(430, 620)
    ENERGY1_IS_VISIBLE = True
    ENERGY2_IS_VISIBLE = True
    ENERGY_TIMER_1 = 0
    ENERGY_TIMER_2 = 0
    WINNER_TEXT = None


def draw_toggle(x, y, status, text_en, text_vi, on_img_en, off_img_en, on_img_vi, off_img_vi):
    text_to_render = text_vi if LANGUAGE == 'T. Việt' else text_en
    text_surface = font.render(text_to_render, True, (0, 0, 0) if not DARK_MODE else (255, 255, 255))
    text_rect = text_surface.get_rect(topleft=(x, y))
    screen.blit(text_surface, text_rect)
    img = on_img_en if status and LANGUAGE == 'ENGLISH' else off_img_en if not status and LANGUAGE == 'ENGLISH' else on_img_vi if status else off_img_vi
    rect = img.get_rect(topleft=(x, y + 50))
    screen.blit(img, rect)
    return rect


def display():
    global TOGGLE_FPS, TOGGLE_BRIGHTNESS, CLOSE, CLOSE_BOX, state
    if state != 'MENU':
        screen.blit(CLOSE, CLOSE.get_rect(center=CLOSE_BOX.center))
    if TOGGLE_FPS:
        fps_text = font.render(f"FPS: {int(clock.get_fps())}", True, (255, 255, 255))
        screen.blit(fps_text, (0, 350))
    if TOGGLE_BRIGHTNESS:
        dark_surface = py.Surface((900, 680))
        dark_surface.fill((0, 0, 0))
        dark_surface.set_alpha(int(dark_slider.value))
        screen.blit(dark_surface, (0, 0))


def lerp(c1, c2, a):
    return tuple(int(c1[i] + (c2[i] - c1[i]) * a) for i in range(3))


def play_sfx():
    global TOGGLE_SFX
    if TOGGLE_SFX:
        CLICK_SFX.play(0)


def blit_text_wrapped(screen, text, font, color, center_x, center_y, max_width):
    words = text.split(' ')
    lines = []
    current_line = ""

    # Wrap text thành các dòng
    for word in words:
        test_line = current_line + (" " if current_line else "") + word
        if font.size(test_line)[0] <= max_width:
            current_line = test_line
        else:
            if current_line:  # Tránh dòng rỗng
                lines.append(current_line)
            current_line = word

    if current_line:
        lines.append(current_line)

    # Tính toán vị trí bắt đầu để căn giữa theo chiều dọc
    total_height = len(lines) * font.get_linesize()
    start_y = center_y - total_height // 2

    # Blit từng dòng lên screen
    for i, line in enumerate(lines):
        text_surface = font.render(line, True, color)
        text_rect = text_surface.get_rect(centerx=center_x, y=start_y + i * font.get_linesize())
        screen.blit(text_surface, text_rect)


def shorten_text(text, max_len=8):
    return text if len(text) <= max_len else text[:max_len - 1] + "..."


def draw_energy_bars():
    max_width = 100
    # Player 1
    ratio1 = min(ENERGY_PLAYER1 / 100, 1.0)
    py.draw.rect(screen, (255, 255, 0), (0, Y_1 - 20, int(max_width * ratio1), 10))
    py.draw.rect(screen, (255, 255, 255), (0, Y_1 - 20, max_width, 10), 2)

    # Player 2
    ratio2 = min(ENERGY_PLAYER2 / 100, 1.0)
    py.draw.rect(screen, (255, 255, 0), (0, Y_2 - 20, int(max_width * ratio2), 10))
    py.draw.rect(screen, (255, 255, 255), (0, Y_2 - 20, max_width, 10), 2)


def set_transparency():
    global CLOSE
    global REPLAY_VI, REPLAY_EN
    global PLAY_VI, PLAY_EN
    global SETTING_EN, SETTING_VI
    global TRASH_BIN
    global TRIANGLE, TRIANGLE2, TRIANGLE3, TRIANGLE4
    CLOSE.set_alpha(CLOSE_TRANSPARENCY)
    REPLAY_VI.set_alpha(REPLAY_TRANSPARENCY)
    REPLAY_EN.set_alpha(REPLAY_TRANSPARENCY)
    PLAY_EN.set_alpha(PLAY_TRANSPARENCY)
    PLAY_VI.set_alpha(PLAY_TRANSPARENCY)
    SETTING_VI.set_alpha(SETTING_TRANSPARENCY)
    SETTING_EN.set_alpha(SETTING_TRANSPARENCY)
    TRASH_BIN.set_alpha(TRASH_TRANSPARENCY)
    TRIANGLE.set_alpha(TRIANGLE_TRANSPARENCY)
    TRIANGLE2.set_alpha(TRIANGLE2_TRANSPARENCY)
    TRIANGLE3.set_alpha(TRIANGLE3_TRANSPARENCY)
    TRIANGLE4.set_alpha(TRIANGLE4_TRANSPARENCY)


def set_volume():
    global TOGGLE_MUSIC, TOGGLE_SFX
    global BG_MUSIC, GAME_MUSIC
    if TOGGLE_MUSIC:
        BG_MUSIC.set_volume(volume_slider.value)
        GAME_MUSIC.set_volume(volume_slider.value)
    else:
        BG_MUSIC.set_volume(0)
        GAME_MUSIC.set_volume(0)
    if TOGGLE_SFX:
        CLICK_SFX.set_volume(sfx_slider.value)
        ROCK_SOUND.set_volume(sfx_slider.value)
        ENERGY_BALL_SOUND.set_volume(sfx_slider.value)
        WIN_SFX.set_volume(sfx_slider.value)
    else:
        ROCK_SOUND.set_volume(0)
        ENERGY_BALL_SOUND.set_volume(0)
        WIN_SFX.set_volume(0)


def set_default_speed(normal, special):
    global backend_perks
    global NORMAL_SPEED1, NORMAL_SPEED2
    if 'Passive' in backend_perks[current_p1_perk_idx]:
        NORMAL_SPEED1 = special
    else:
        NORMAL_SPEED1 = normal
    if 'Passive' in backend_perks[current_p2_perk_idx]:
        NORMAL_SPEED2 = special
    else:
        NORMAL_SPEED2 = normal
    if "Slow" in backend_perks[current_p1_perk_idx]:
        NORMAL_SPEED1 = 7
    if "Slow" in backend_perks[current_p2_perk_idx]:
        NORMAL_SPEED2 = 7
    if 'Test' in backend_perks[current_p1_perk_idx]:
        NORMAL_SPEED1 = 999


def display_plr():
    global P1_SKIN, P2_SKIN
    global YELLOW_SHIP_G, GREEN_SHIP_G
    global Y_1, Y_2
    global P1_BALL_X, P2_BALL_X

    if P1_SKIN == 'Yellow':
        screen.blit(YELLOW_SHIP_G, (0, Y_1))
        screen.blit(YELLOW_BALL, (P1_BALL_X, 5))
    else:
        screen.blit(GREEN_SHIP_G, (0, Y_1))
        screen.blit(GREEN_BALL, (P1_BALL_X, 5))
    if P2_SKIN == 'Green':
        screen.blit(GREEN_SHIP_G, (0, Y_2))
        screen.blit(GREEN_BALL, (P2_BALL_X, 50))
    else:
        screen.blit(YELLOW_SHIP_G, (0, Y_2))
        screen.blit(YELLOW_BALL, (P2_BALL_X, 50))


save_list, saved_color_list = load_config()
while True:
    MOUSE_POS = py.mouse.get_pos()
    set_volume()
    set_transparency()
    LANGUAGE = language_dropdown.options[language_dropdown.selected_index]
    perks = pk.get_perks(LANGUAGE)
    perk_desc = pk.get_desc(LANGUAGE)
    set_default_speed(6, 9)

    DIFFICULTY = difficulty_dropdown.options[difficulty_dropdown.selected_index]
    color_choice = color_dropdown.options[color_dropdown.selected_index]
    saved_color_choice = saved_color_dropdown.options[saved_color_dropdown.selected_index]
    if color_choice == 'Custom' or color_choice == 'Tùy chỉnh':
        BG_COLOR = (int(red_slider.value), int(green_slider.value), int(blue_slider.value))
    elif color_choice == 'Rainbow' or color_choice == 'Cầu vồng':
        speed = 1
        t = (py.time.get_ticks() / 1000) % (len(rgb_colors) * speed)
        index = int(t // speed)
        next_index = (index + 1) % len(rgb_colors)
        alpha = (t % speed) / speed
        BG_COLOR = lerp(rgb_colors[index], rgb_colors[next_index], alpha)
    else:
        BG_COLOR = colors[color_dropdown.selected_index]
    for event in py.event.get():
        if event.type == py.QUIT:
            save_config(save_list, saved_color_list)
            py.quit()
            sys.exit()
        # ===== MENU =====
        if state == 'MENU':
            if PLAY_BOX.collidepoint(MOUSE_POS):
                PLAY_TRANSPARENCY = 150
                if event.type == py.MOUSEBUTTONDOWN and event.button == 1:
                    state = 'BASE'
                    play_sfx()
                    reset_game()
            elif SETTING_BOX.collidepoint(MOUSE_POS):
                SETTING_TRANSPARENCY = 150
                if event.type == py.MOUSEBUTTONDOWN and event.button == 1:
                    play_sfx()
                    state = 'SETTINGS'
            else:
                PLAY_TRANSPARENCY = 255
                SETTING_TRANSPARENCY = 255

        # ===== SETTINGS =====
        elif state == 'SETTINGS':
            if CLOSE_BOX.collidepoint(MOUSE_POS):
                CLOSE_TRANSPARENCY = 150
                if event.type == py.MOUSEBUTTONDOWN and event.button == 1:
                    state = 'MENU'
                    play_sfx()
                    if TOGGLE_MUSIC:
                        GAME_MUSIC.stop()
            else:
                CLOSE_TRANSPARENCY = 255
            BUTTONS[0].centerx = screen.get_width() // 2
            BUTTONS[0].y = 550
            if BUTTONS[0].collidepoint(MOUSE_POS):
                if event.type == py.MOUSEBUTTONDOWN and event.button == 1:
                    state = 'ADV SETTINGS'
                    play_sfx()
            volume_slider.handle_event(event)
            volume_input.handle_event(event, volume_slider)
            volume_input.text = str(int(volume_slider.value * 100))
            language_dropdown.handle_event(event)
            difficulty_dropdown.handle_event(event)
        elif state == 'ADV SETTINGS':
            if CLOSE_BOX.collidepoint(MOUSE_POS):
                CLOSE_TRANSPARENCY = 150
                if event.type == py.MOUSEBUTTONDOWN and event.button == 1:
                    state = 'SETTINGS'
                    play_sfx()
                    if TOGGLE_MUSIC:
                        GAME_MUSIC.stop()
            else:
                CLOSE_TRANSPARENCY = 255
            dark_slider.handle_event(event)
            dark_input.handle_event(event, dark_slider)
            dark_input.text = str(int(dark_slider.value))
            firework_slider.handle_event(event)
            firework_input.handle_event(event, firework_slider)
            firework_input.text = str(int(firework_slider.value))
            sfx_slider.handle_event(event)
            sfx_input.handle_event(event, sfx_slider)
            sfx_input.text = str(int(sfx_slider.value * 100))
            if event.type == py.MOUSEBUTTONDOWN and event.button == 1:
                mouse_x, mouse_y = event.pos
                if draw_toggle(200, 100, TOGGLE_MUSIC, 'Music', 'Âm nhạc', TOGGLE_ON_EN, TOGGLE_OFF_EN, TOGGLE_ON_VI,
                               TOGGLE_OFF_VI).collidepoint(mouse_x, mouse_y):
                    TOGGLE_MUSIC = not TOGGLE_MUSIC
                    play_sfx()
                elif draw_toggle(200, 250, TOGGLE_SFX, 'Sound Effects', 'H.Ứng âm thanh', TOGGLE_ON_EN,
                                 TOGGLE_OFF_EN, TOGGLE_ON_VI, TOGGLE_OFF_VI).collidepoint(mouse_x, mouse_y):
                    TOGGLE_SFX = not TOGGLE_SFX
                    play_sfx()
                elif draw_toggle(200, 400, TOGGLE_FIREWORKS, 'Fireworks', 'Pháo hoa', TOGGLE_ON_EN, TOGGLE_OFF_EN,
                                 TOGGLE_ON_VI, TOGGLE_OFF_VI).collidepoint(mouse_x, mouse_y):
                    TOGGLE_FIREWORKS = not TOGGLE_FIREWORKS
                    play_sfx()
                elif draw_toggle(400, 100, SPEED_DISPLAY, 'Speed Display', 'Hiển thị tốc độ', TOGGLE_ON_EN,
                                 TOGGLE_OFF_EN, TOGGLE_ON_VI, TOGGLE_OFF_VI).collidepoint(mouse_x, mouse_y):
                    SPEED_DISPLAY = not SPEED_DISPLAY
                    play_sfx()
                elif draw_toggle(400, 250, DARK_MODE, 'Dark Mode', 'Chế độ tối', TOGGLE_ON_EN, TOGGLE_OFF_EN,
                                 TOGGLE_ON_VI, TOGGLE_OFF_VI).collidepoint(mouse_x, mouse_y):
                    DARK_MODE = not DARK_MODE
                    play_sfx()
                    if DARK_MODE:
                        previous_color_idx = color_dropdown.selected_index  # lưu màu hiện tại
                        color_dropdown.selected_index = 10
                    else:
                        color_dropdown.selected_index = previous_color_idx  # khôi phục màu cũ
                elif draw_toggle(600, 100, TOGGLE_BRIGHTNESS, 'Brightness', 'Nền tối', TOGGLE_ON_EN, TOGGLE_OFF_EN,
                                 TOGGLE_ON_VI, TOGGLE_OFF_VI).collidepoint(mouse_x, mouse_y):
                    TOGGLE_BRIGHTNESS = not TOGGLE_BRIGHTNESS
                    play_sfx()
                elif draw_toggle(600, 250, TOGGLE_FPS, 'Show FPS', 'Hiện FPS', TOGGLE_ON_EN, TOGGLE_OFF_EN,
                                 TOGGLE_ON_VI, TOGGLE_OFF_VI).collidepoint(mouse_x, mouse_y):
                    TOGGLE_FPS = not TOGGLE_FPS
                    play_sfx()
                elif draw_toggle(400, 400, TOGGLE_PLAYER_MARK, "Players' Mark", 'Đánh dấu N.chơi', TOGGLE_ON_EN,
                                 TOGGLE_OFF_EN, TOGGLE_ON_VI, TOGGLE_OFF_VI).collidepoint(mouse_x, mouse_y):
                    TOGGLE_PLAYER_MARK = not TOGGLE_PLAYER_MARK
                    play_sfx()
                elif BUTTONS[1].collidepoint(MOUSE_POS):
                    state = 'VSETTINGS'
                    play_sfx()
                elif BUTTONS[3].collidepoint(MOUSE_POS):
                    state = 'PSETTINGS'
                    play_sfx()
        elif state == 'VSETTINGS':
            if CLOSE_BOX.collidepoint(MOUSE_POS):
                CLOSE_TRANSPARENCY = 150
                if event.type == py.MOUSEBUTTONDOWN and event.button == 1:
                    state = 'ADV SETTINGS'
                    play_sfx()
                    if TOGGLE_MUSIC:
                        GAME_MUSIC.stop()
            else:
                CLOSE_TRANSPARENCY = 255
            red_slider.handle_event(event)
            red_input.handle_event(event, red_slider)
            red_input.text = str(int(red_slider.value))
            green_slider.handle_event(event)
            green_input.handle_event(event, green_slider)
            green_input.text = str(int(green_slider.value))
            blue_slider.handle_event(event)
            blue_input.handle_event(event, blue_slider)
            blue_input.text = str(int(blue_slider.value))
            save_input.handle_event(event)
            color_dropdown.handle_event(event)
            saved_color_dropdown.handle_event(event)
            saved_color_dropdown.options = save_list
            if ((color_choice != 'Custom' and color_choice != 'Tùy chỉnh')
                    and (color_choice != 'Rainbow' and color_choice != 'Cầu vồng')):
                try:
                    preset_color = colors[color_dropdown.selected_index]
                    red_slider.value = preset_color[0]
                    green_slider.value = preset_color[1]
                    blue_slider.value = preset_color[2]
                except IndexError:
                    pass
            else:
                preset_color = None
            if saved_color_choice != 'Default' and saved_color_choice != 'Mặc định':
                try:
                    saved_color_index = save_list.index(saved_color_choice)
                    saved_color = saved_color_list[saved_color_index]
                    red_slider.value = saved_color[0]
                    green_slider.value = saved_color[1]
                    blue_slider.value = saved_color[2]
                    color_dropdown.selected_index = color_dropdown.options.index(
                        'Custom' if LANGUAGE == 'ENGLISH' else 'Tùy chỉnh')
                except (IndexError, ValueError):
                    pass
            if (color_choice == 'Black' or color_choice == 'Đen' or BG_COLOR == (0, 0, 0)
                    or BG_COLOR == (30, 30, 30) or color_choice == 'Dark' or color_choice == 'Tối'
                    or (BG_COLOR[0] <= 30 and BG_COLOR[1] <= 30 and BG_COLOR[2] <= 30)):
                DARK_MODE = True
            else:
                DARK_MODE = False
            if BUTTONS[2].collidepoint(MOUSE_POS):
                if event.type == py.MOUSEBUTTONDOWN and event.button == 1:
                    save_name = save_input.text
                    if save_name != '':
                        if save_name not in save_list:
                            save_list.append(save_name)
                            saved_color_list.append(
                                (int(red_slider.value), int(green_slider.value), int(blue_slider.value)))
            if TRASH_BOX.collidepoint(MOUSE_POS):
                TRASH_TRANSPARENCY = 150
                if event.type == py.MOUSEBUTTONDOWN and event.button == 1:
                    if saved_color_choice != 'Default' and saved_color_choice != 'Mặc định':
                        try:
                            saved_color_index = save_list.index(saved_color_choice)
                            save_list.pop(saved_color_index)
                            saved_color_list.pop(saved_color_index)
                            saved_color_dropdown.selected_index = 0
                            save_config(save_list, saved_color_list)
                        except (IndexError, ValueError):
                            pass
            else:
                TRASH_TRANSPARENCY = 255
        elif state == 'PSETTINGS':
            triangle_surface.set_alpha(0)
            triangle_surface2.set_alpha(0)
            triangle_surface3.set_alpha(0)
            triangle_surface4.set_alpha(0)

            if CLOSE_BOX.collidepoint(MOUSE_POS):
                CLOSE_TRANSPARENCY = 150
                if event.type == py.MOUSEBUTTONDOWN and event.button == 1:
                    state = 'ADV SETTINGS'
                    play_sfx()
            else:
                CLOSE_TRANSPARENCY = 250
            if TRIANGLE_BOX.collidepoint(MOUSE_POS):
                TRIANGLE_TRANSPARENCY = 150
                if event.type == py.MOUSEBUTTONDOWN and event.button == 1:
                    play_sfx()
                    triangle_surface.fill((0, 0, 0))
                    triangle_surface.set_alpha(100)
                    if P1_SKIN == 'Yellow':
                        P1_SKIN = 'Green'
                    else:
                        P1_SKIN = 'Yellow'
            else:
                TRIANGLE_TRANSPARENCY = 255
            if TRIANGLE_BOX2.collidepoint(MOUSE_POS):
                TRIANGLE2_TRANSPARENCY = 150
                if event.type == py.MOUSEBUTTONDOWN and event.button == 1:
                    play_sfx()
                    triangle_surface2.fill((0, 0, 0))
                    triangle_surface2.set_alpha(100)
                    if P2_SKIN == 'Green':
                        P2_SKIN = 'Yellow'
                    else:
                        P2_SKIN = 'Green'
            else:
                TRIANGLE2_TRANSPARENCY = 255
            if TRIANGLE_BOX3.collidepoint(MOUSE_POS):
                TRIANGLE3_TRANSPARENCY = 150
                if event.type == py.MOUSEBUTTONDOWN and event.button == 1:
                    play_sfx()
                    triangle_surface3.fill((0, 0, 0))
                    triangle_surface3.set_alpha(100)
                    current_p1_perk_idx = (current_p1_perk_idx + 1) % len(perks)
            else:
                TRIANGLE3_TRANSPARENCY = 255
            if TRIANGLE_BOX4.collidepoint(MOUSE_POS):
                TRIANGLE4_TRANSPARENCY = 150
                if event.type == py.MOUSEBUTTONDOWN and event.button == 1:
                    play_sfx()
                    triangle_surface4.fill((0, 0, 0))
                    triangle_surface4.set_alpha(100)
                    current_p2_perk_idx = (current_p2_perk_idx + 1) % len(perks)
            else:
                TRIANGLE4_TRANSPARENCY = 255

        # ===== IN GAME =====
        elif state == 'BASE':
            if CLOSE_BOX.collidepoint(MOUSE_POS):
                CLOSE_TRANSPARENCY = 150
                if event.type == py.MOUSEBUTTONDOWN and event.button == 1:
                    state = 'MENU'
                    play_sfx()
                    if TOGGLE_MUSIC:
                        GAME_MUSIC.stop()
                        BG_MUSIC.play(-1)
            elif py.Rect(0, 0, 165, 50).collidepoint(MOUSE_POS):
                SETTING_TRANSPARENCY = 150
                if event.type == py.MOUSEBUTTONDOWN and event.button == 1:
                    state = 'SETTINGS'
                    play_sfx()
                    if TOGGLE_MUSIC:
                        GAME_MUSIC.stop()
                        BG_MUSIC.play(-1)
            else:
                CLOSE_TRANSPARENCY = SETTING_TRANSPARENCY = 255

        # ===== END GAME =====
        elif state == 'END':
            if REPLAY_BOX.collidepoint(MOUSE_POS):
                REPLAY_TRANSPARENCY = 150
                if event.type == py.MOUSEBUTTONDOWN and event.button == 1:
                    play_sfx()
                    state = 'BASE'
                    if TOGGLE_MUSIC:
                        GAME_MUSIC.stop()
                        GAME_MUSIC.play(-1)
                    reset_game()
            elif BUTTONS[12].collidepoint(MOUSE_POS):
                SETTING_TRANSPARENCY = 150
                if event.type == py.MOUSEBUTTONDOWN and event.button == 1:
                    state = 'SETTINGS'
                    play_sfx()
            else:
                REPLAY_TRANSPARENCY = 255
                SETTING_TRANSPARENCY = 255

    # ===== MENU =====
    if state == 'MENU':
        screen.fill(BG_COLOR)

        if LANGUAGE == 'ENGLISH':
            screen.blit(MENU_BG_EN, (0, 0))
            screen.blit(PLAY_EN, (190, 380))
            screen.blit(SETTING_EN, (490, 380))
            py.display.set_caption('Dragon Boat Race')
        else:
            screen.blit(MENU_BG_VI, (0, 0))
            screen.blit(PLAY_VI, (190, 380))
            screen.blit(SETTING_VI, (490, 380))
            py.display.set_caption('Đua thuyền rồng')
        display()

    # ===== SETTINGS =====
    elif state == 'SETTINGS':
        screen.fill(BG_COLOR)

        if LANGUAGE == 'ENGLISH':
            screen.blit(SETTING_MENU_EN, (0, 0))
        else:
            screen.blit(SETTING_MENU_VI, (0, 0))
        volume_slider.draw(screen, font, 'Volume' if LANGUAGE == 'ENGLISH' else 'Âm lượng', DARK_MODE)
        volume_input.draw(screen)
        language_dropdown.draw(screen)
        difficulty_options = ['EASY', 'MEDIUM', 'HARD', 'INSANE',
                              'EXTREME'] if LANGUAGE == 'ENGLISH' else ['DỄ', 'THƯỜNG', 'KHÓ',
                                                                        'ĐIÊN LOẠN', 'CỰC KHÓ']
        difficulty_dropdown.options = difficulty_options
        difficulty_dropdown.draw(screen)
        BUTTONS[0].centerx = screen.get_width() // 2
        BUTTONS[0].y = 550
        py.draw.rect(screen, (255, 255, 0), BUTTONS[0])
        ADVANCED_SETTINGS_TEXT = font.render(
            'ADVANCED SETTINGS' if LANGUAGE == 'ENGLISH' else 'CÀI ĐẶT NÂNG CAO', True, (0, 0, 0))
        screen.blit(ADVANCED_SETTINGS_TEXT, ADVANCED_SETTINGS_TEXT.get_rect(center=BUTTONS[0].center))
        display()
    elif state == 'ADV SETTINGS':
        screen.fill(BG_COLOR)
        if TOGGLE_BRIGHTNESS:
            dark_surface = py.Surface((900, 680))
            dark_surface.fill((0, 0, 0))
            dark_surface.set_alpha(int(dark_slider.value))
            screen.blit(dark_surface, (0, 0))
        draw_toggle(200, 100, TOGGLE_MUSIC, 'Music', 'Âm nhạc', TOGGLE_ON_EN, TOGGLE_OFF_EN, TOGGLE_ON_VI,
                    TOGGLE_OFF_VI)
        draw_toggle(200, 250, TOGGLE_SFX, 'Sound Effects', 'H.Ứng âm thanh', TOGGLE_ON_EN, TOGGLE_OFF_EN,
                    TOGGLE_ON_VI, TOGGLE_OFF_VI)
        draw_toggle(200, 400, TOGGLE_FIREWORKS, 'Fireworks', 'Pháo hoa', TOGGLE_ON_EN, TOGGLE_OFF_EN, TOGGLE_ON_VI,
                    TOGGLE_OFF_VI)
        draw_toggle(600, 100, TOGGLE_BRIGHTNESS, 'Brightness (Light to Dark)', 'Độ sáng (Sáng đến tối)', TOGGLE_ON_EN,
                    TOGGLE_OFF_EN, TOGGLE_ON_VI,
                    TOGGLE_OFF_VI)
        draw_toggle(600, 250, TOGGLE_FPS, 'Show FPS', 'Hiện FPS', TOGGLE_ON_EN, TOGGLE_OFF_EN, TOGGLE_ON_VI,
                    TOGGLE_OFF_VI)
        draw_toggle(400, 400, TOGGLE_PLAYER_MARK, "Highlight Players", 'Đánh dấu người chơi', TOGGLE_ON_EN, TOGGLE_OFF_EN,
                    TOGGLE_ON_VI, TOGGLE_OFF_VI)
        draw_toggle(400, 100, SPEED_DISPLAY, 'Speed Display', 'Hiển thị tốc độ', TOGGLE_ON_EN, TOGGLE_OFF_EN,
                    TOGGLE_ON_VI, TOGGLE_OFF_VI)
        draw_toggle(400, 250, DARK_MODE, 'Dark Mode', 'Chế độ tối', TOGGLE_ON_EN, TOGGLE_OFF_EN, TOGGLE_ON_VI,
                    TOGGLE_OFF_VI)

        dark_slider.draw(screen, font, 'Brightness' if LANGUAGE == 'ENGLISH' else 'Độ sáng',
                         DARK_MODE)
        dark_input.draw(screen)
        firework_slider.draw(screen, font, 'Fireworks' if LANGUAGE == 'ENGLISH' else 'Pháo hoa',
                             DARK_MODE)
        firework_input.draw(screen)
        sfx_slider.draw(screen, font, 'SFX', DARK_MODE)
        sfx_input.draw(screen)
        py.draw.rect(screen, (255, 255, 0), BUTTONS[1])
        blit_text_wrapped(
            screen,
            'Back ground' if LANGUAGE == 'ENGLISH' else 'Nền',
            font,
            (0, 0, 0),
            BUTTONS[1].centerx,
            BUTTONS[1].centery,
            100
        )
        py.draw.rect(screen, (255, 255, 0), BUTTONS[3])
        blit_text_wrapped(
            screen,
            'Player' if LANGUAGE == 'ENGLISH' else 'Người chơi',
            font,
            (0, 0, 0),
            BUTTONS[3].centerx,
            BUTTONS[3].centery,
            100
        )
        display()
    elif state == 'VSETTINGS':
        screen.fill(BG_COLOR)
        red_slider.draw(screen, font, 'Red' if LANGUAGE == 'ENGLISH' else 'Đỏ', DARK_MODE)
        green_slider.draw(screen, font, 'Green' if LANGUAGE == 'ENGLISH' else 'Xanh lục', DARK_MODE)
        blue_slider.draw(screen, font, 'Blue' if LANGUAGE == 'ENGLISH' else 'Xanh dương', DARK_MODE)
        red_input.draw(screen)
        green_input.draw(screen)
        blue_input.draw(screen)
        save_input.draw(screen)
        color_options = [
            'Default', 'Green', 'Sky blue',
            'Red', 'Yellow', 'Orange', 'White',
            'Black', 'Light green', 'Purple', 'Dark', 'Rainbow', 'Custom'
        ] if LANGUAGE == 'ENGLISH' else [
            'Mặc định', 'Xanh lục', 'Xanh lam',
            'Đỏ', 'Vàng', 'Cam', 'Trắng',
            'Đen', 'Xanh nhạt', 'Tím', 'Tối', 'Cầu vồng', 'Tùy chỉnh'
        ]
        color_dropdown.options = color_options
        color_dropdown.draw(screen)
        saved_color_dropdown.draw(screen)
        py.draw.rect(screen, (255, 255, 0), BUTTONS[2])
        note_text = font.render('Scrollable!' if LANGUAGE == 'ENGLISH' else 'Kéo được!', True,
                                (255, 255, 255) if DARK_MODE else (0, 0, 0))
        save_text = font.render('Save!' if LANGUAGE == 'ENGLISH' else 'Lưu!', True, (0, 0, 0))
        screen.blit(note_text, (500, 120))
        screen.blit(note_text, (700, 120))
        screen.blit(save_text, save_text.get_rect(center=BUTTONS[2].center))
        screen.blit(TRASH_BIN, (600, 400))
        display()
    elif state == 'PSETTINGS':
        screen.fill(BG_COLOR)
        if P1_SKIN == 'Yellow':
            screen.blit(YELLOW_SHIP, (100, 150))
        else:
            screen.blit(GREEN_SHIP, (100, 150))
        if P2_SKIN == 'Green':
            screen.blit(GREEN_SHIP, (100, 500))
        else:
            screen.blit(YELLOW_SHIP, (100, 500))
        screen.blit(TRIANGLE, TRIANGLE.get_rect(center=TRIANGLE_BOX.center))
        screen.blit(TRIANGLE2, TRIANGLE2.get_rect(center=TRIANGLE_BOX2.center))
        screen.blit(TRIANGLE3, TRIANGLE3.get_rect(center=TRIANGLE_BOX3.center))
        screen.blit(TRIANGLE4, TRIANGLE4.get_rect(center=TRIANGLE_BOX4.center))

        # Display Surface
        screen.blit(triangle_surface, TRIANGLE.get_rect(center=TRIANGLE_BOX.center))
        screen.blit(triangle_surface2, TRIANGLE2.get_rect(center=TRIANGLE_BOX2.center))
        screen.blit(triangle_surface3, TRIANGLE3.get_rect(center=TRIANGLE_BOX3.center))
        screen.blit(triangle_surface4, TRIANGLE4.get_rect(center=TRIANGLE_BOX4.center))

        perk_text = font.render('Perks' if LANGUAGE == 'ENGLISH' else 'Kĩ năng', True,
                                (255, 255, 255) if DARK_MODE else (0, 0, 0))
        py.draw.rect(screen, (0, 0, 0), BUTTONS[4])
        py.draw.rect(screen, (0, 0, 0), BUTTONS[5])
        perk1_text = font.render(perks[current_p1_perk_idx], True, (255, 255, 255) if DARK_MODE else (0, 0, 0))
        perk2_text = font.render(perks[current_p2_perk_idx], True, (255, 255, 255) if DARK_MODE else (0, 0, 0))
        blit_text_wrapped(
            screen,
            perk_desc[current_p1_perk_idx],
            font,
            (255, 255, 255) if DARK_MODE else (0, 0, 0),
            BUTTONS[8].centerx,
            BUTTONS[8].centery,
            400
        )
        blit_text_wrapped(
            screen,
            perk_desc[current_p2_perk_idx],
            font,
            (255, 255, 255) if DARK_MODE else (0, 0, 0),
            BUTTONS[9].centerx,
            BUTTONS[9].centery,
            400
        )
        blit_text_wrapped(
            screen,
            'Player 1 (Hold LeftShift to Burst)' if LANGUAGE == 'ENGLISH' else
            'Người chơi 1 (Giữ Shift trái để Burst/Chạy nhanh)',
            font,
            (255, 255, 255) if DARK_MODE else (0, 0, 0),
            BUTTONS[13].centerx,
            BUTTONS[13].centery,
            400
        )
        blit_text_wrapped(
            screen,
            'Player 2 (Hold RightCTRL to Burst)' if LANGUAGE == 'ENGLISH'
            else 'Người chơi 2 (Giữ CTRL phải để Burst/Chạy nhanh)',
            font,
            (255, 255, 255) if DARK_MODE else (0, 0, 0),
            BUTTONS[14].centerx,
            BUTTONS[14].centery,
            400
        )
        screen.blit(perk1_text, perk1_text.get_rect(center=BUTTONS[6].center))
        screen.blit(perk2_text, perk2_text.get_rect(center=BUTTONS[7].center))
        screen.blit(perk_text, perk_text.get_rect(center=BUTTONS[10].center))
        screen.blit(perk_text, perk_text.get_rect(center=BUTTONS[11].center))
        display()

    # ===== IN GAME =====
    elif state == 'BASE':
        screen.fill(BG_COLOR)
        if not timestopping2:
            X_WAVE_1 -= SPEED_1
            P1_BALL_X += SPEED_1 / 100
            DISTANCE_1 += SPEED_1
        if not timestopping:
            P2_BALL_X += SPEED_2 / 100
            X_WAVE_2 -= SPEED_2
            DISTANCE_2 += SPEED_2
        if not timestopping and not timestopping2:
            X_BG -= 1
        if DISTANCE_1 >= FINISH_LINE_WORLD_X:
            WINNER_TEXT = WINNER.render('PLAYER 1 WINS!', True, (255, 255, 0))
            state = 'END'
            if TOGGLE_FIREWORKS:
                firework_spawner(int(firework_slider.value))
            WIN_SFX.play(0)
        elif DISTANCE_2 >= FINISH_LINE_WORLD_X:
            WINNER_TEXT = WINNER.render('PLAYER 2 WINS!', True, (0, 100, 0))
            state = 'END'
            if TOGGLE_FIREWORKS:
                firework_spawner(int(firework_slider.value))
            WIN_SFX.play(0)
        if ENERGY1_IS_VISIBLE:
            if not timestopping2:
                X_POWER_1 -= SPEED_1
                if X_POWER_1 < -480:
                    X_POWER_1 = 900
                    Y_POWER_1 = random.randint(130, 350)
        if ENERGY2_IS_VISIBLE:
            if not timestopping:
                X_POWER_2 -= SPEED_2
                if X_POWER_2 < -480:
                    X_POWER_2 = 900
                    Y_POWER_2 = random.randint(430, 620)
        if not ENERGY1_IS_VISIBLE and py.time.get_ticks() - ENERGY_TIMER_1 >= ENERGY_RESPAWN_TIME:
            while not timestopping2:
                X_POWER_1 = 900
                Y_POWER_1 = random.randint(130, 350)
                ball_rect = ENERGY_BALL.get_rect(topleft=(X_POWER_1, Y_POWER_1))
                collision = False
                for rock in ROCKS:
                    rock_rect = ROCK_IMG.get_rect(topleft=(rock[0], rock[1]))
                    if ball_rect.colliderect(rock_rect):
                        collision = True
                        break
                if not collision:
                    ENERGY1_IS_VISIBLE = True
                    break
        if not ENERGY2_IS_VISIBLE and py.time.get_ticks() - ENERGY_TIMER_2 >= ENERGY_RESPAWN_TIME:
            while not timestopping:
                X_POWER_2 = 900
                Y_POWER_2 = random.randint(430, 620)
                ball_rect = ENERGY_BALL.get_rect(topleft=(X_POWER_2, Y_POWER_2))
                collision = False
                for rock in ROCKS:
                    rock_rect = ROCK_IMG.get_rect(topleft=(rock[0], rock[1]))
                    if ball_rect.colliderect(rock_rect):
                        collision = True
                        break
                if not collision:
                    ENERGY2_IS_VISIBLE = True
                    break

        if X_BG < -1022:
            X_BG = 0
        if X_WAVE_1 < -1022:
            X_WAVE_1 = 0
        if X_WAVE_2 < -1022:
            X_WAVE_2 = 0
        KEYS = py.key.get_pressed()

        # ===== PLAYER 1 FULL CONTROL =====
        if not timestopping2:
            if KEYS[py.K_w] and Y_1 > 110:
                Y_1 -= 5
            if KEYS[py.K_s] and Y_1 < 350:
                Y_1 += 5
            # Player 1 Burst Ability (LSHIFT key)
            if KEYS[py.K_LSHIFT] and not flashstepping:
                if ENERGY_PLAYER1 > 0:
                    if backend_perks[current_p1_perk_idx] == 'More Energy':
                        ENERGY_PLAYER1 -= 0.075
                    else:
                        ENERGY_PLAYER1 -= 0.2
                    if SPEED_1 >= NORMAL_SPEED1:  # If speed is not below
                        if backend_perks[current_p1_perk_idx] == 'Faster Burst':  # Extra Speed Boost
                            SPEED_1 = min(21, SPEED_1 + 0.8)
                        else:
                            SPEED_1 = min(13, SPEED_1 + 0.1)
                    else:
                        if backend_perks[current_p1_perk_idx] == 'Faster Burst':  # Extra Speed Boost
                            SPEED_1 = min(NORMAL_SPEED1, SPEED_1 + 0.8)  # x8 Recovery
                        else:
                            SPEED_1 = min(NORMAL_SPEED1, SPEED_1 + 0.1)
                else:  # Out of Energy
                    if SPEED_1 > NORMAL_SPEED1 and not ('Speeds' in backend_perks[current_p1_perk_idx]):
                        SPEED_1 = max(NORMAL_SPEED1, SPEED_1 - 0.1)
                    elif SPEED_1 < NORMAL_SPEED1:
                        if 'Passive' in backend_perks[current_p1_perk_idx]:
                            SPEED_1 = min(NORMAL_SPEED1, SPEED_1 + 0.05)
                        else:
                            SPEED_1 = min(NORMAL_SPEED1, SPEED_1 + 0.025)
            else:  # Not Bursting
                if SPEED_1 > NORMAL_SPEED1 and not ('Speeds' in backend_perks[current_p1_perk_idx]):
                    SPEED_1 = max(NORMAL_SPEED1, SPEED_1 - 0.1)
                elif SPEED_1 < NORMAL_SPEED1:
                    if 'Passive' in backend_perks[current_p1_perk_idx]:
                        SPEED_1 = min(NORMAL_SPEED1, SPEED_1 + 0.05)
                    elif 'Test' in backend_perks[current_p1_perk_idx]:
                        SPEED_1 = min(NORMAL_SPEED1, SPEED_1 + 10)
                    else:
                        SPEED_1 = min(NORMAL_SPEED1, SPEED_1 + 0.025)
            # SPECIAL ABILITY (FLASH STEP / TIMESTOP)
            if KEYS[py.K_c]:
                if 'Flash' in backend_perks[current_p1_perk_idx]:
                    flashstepping, flashstep_start, last_flashstep, flashstep_pack = pk.try_activate_ability(
                        flashstepping, flashstep_start, last_flashstep, flashstep_pack, py.time.get_ticks()
                    )
                elif 'Time' in backend_perks[current_p1_perk_idx]:
                    timestopping, ts_start, last_ts, timestop_pack = pk.try_activate_ability(
                        timestopping, ts_start, last_ts, timestop_pack, py.time.get_ticks()
                    )

            if timestopping:
                current_time3 = py.time.get_ticks()
                ts_surface.fill((0, 0, 0))
                ts_surface.set_alpha(100)
                SPEED_1 = min(20, SPEED_1 + 1)
                SPEED_2 = NORMAL_SPEED2
                if current_time3 - ts_start >= timestop_pack[1]:
                    timestopping = False
            else:
                ts_surface.set_alpha(0)
            if flashstepping:
                current_time = py.time.get_ticks()
                SPEED_1 = min(25, SPEED_1 + 1)
                if current_time - flashstep_start >= flashstep_pack[1]:
                    flashstepping = False  # hết duration
        # ===== PLAYER 2 FULL CONTROL =====
        if not timestopping:
            if KEYS[py.K_UP] and Y_2 > 380:
                Y_2 -= 5
            if KEYS[py.K_DOWN] and Y_2 < 610:
                Y_2 += 5
            if KEYS[py.K_RCTRL] and not flashstepping2:
                if ENERGY_PLAYER2 > 0:  # While Bursting
                    if 'Energy' in backend_perks[current_p2_perk_idx]:
                        ENERGY_PLAYER2 -= 0.075
                    else:
                        ENERGY_PLAYER2 -= 0.2
                    if 'Burst' in backend_perks[current_p2_perk_idx]:
                        SPEED_2 = min(21, SPEED_2 + 0.8)  # Max speed capped at 21, 8x faster windup
                    else:
                        SPEED_2 = min(13, SPEED_2 + 0.1)  # Max speed capped at 13, normal windup
                else:  # If out of energy, but still holding ability keybind
                    if SPEED_2 > NORMAL_SPEED2 and not ('Speeds' in backend_perks[current_p2_perk_idx]):
                        SPEED_2 = max(NORMAL_SPEED2, SPEED_2 - 0.1)
                    elif SPEED_2 < NORMAL_SPEED2:
                        if 'Passive' in backend_perks[current_p2_perk_idx]:
                            SPEED_2 = min(NORMAL_SPEED2, SPEED_2 + 0.05)
                        else:
                            SPEED_2 = min(NORMAL_SPEED2, SPEED_2 + 0.025)
            else:  # If not holding ability key (Handle the same as out of energy)
                if SPEED_2 > NORMAL_SPEED2 and not ('Speeds' in backend_perks[current_p2_perk_idx]):
                    SPEED_2 = max(NORMAL_SPEED2, SPEED_2 - 0.1)
                elif SPEED_2 < NORMAL_SPEED2:
                    if 'Passive' in backend_perks[current_p2_perk_idx]:
                        SPEED_2 = min(NORMAL_SPEED2, SPEED_2 + 0.05)
                    else:
                        SPEED_2 = min(NORMAL_SPEED2, SPEED_2 + 0.025)

            # ===== FLASH STEP + TIME-STOP =====
            if KEYS[py.K_BACKSLASH]:
                if 'Flash' in backend_perks[current_p2_perk_idx]:
                    flashstepping2, flashstep_start2, last_flashstep2, flashstep_pack2 = pk.try_activate_ability(
                        flashstepping2, flashstep_start2, last_flashstep2, flashstep_pack2, py.time.get_ticks()
                    )
                elif 'Time' in backend_perks[current_p2_perk_idx]:
                    timestopping2, ts_start2, last_ts2, timestop_pack2 = pk.try_activate_ability(
                        timestopping2, ts_start2, last_ts2, timestop_pack2, py.time.get_ticks()
                    )
            if flashstepping2:
                current_time2 = py.time.get_ticks()
                SPEED_2 = min(25, SPEED_2 + 1)
                if current_time2 - flashstep_start2 >= flashstep_pack2[1]:
                    flashstepping2 = False  # hết duration
            if timestopping2:
                current_time4 = py.time.get_ticks()
                ts_surface.fill((0, 0, 0))
                ts_surface.set_alpha(100)
                SPEED_2 = min(20, SPEED_2 + 1)
                SPEED_1 = NORMAL_SPEED1
                if current_time4 - ts_start2 >= timestop_pack2[1]:
                    timestopping2 = False
            else:
                ts_surface.set_alpha(0)
        if 'Dark' in backend_perks[current_p1_perk_idx]:
            current_time5 = py.time.get_ticks()
            if current_time5 - last_create_rocks >= 10000 and ability_counts < 3:
                create_rocks_start = current_time5
                last_create_rocks = current_time5
                spawn_rock(2, 2)
                ability_counts += 1
                print('Created rocks using dark magic!')

        if 'Dark' in backend_perks[current_p2_perk_idx]:
            current_time6 = py.time.get_ticks()
            if current_time6 - last_create_rocks2 >= 10000 and ability_counts2 < 3:
                create_rocks_start2 = current_time6
                last_create_rocks2 = current_time6
                spawn_rock(2, 1)
                ability_counts2 += 1
                print('Created rocks using dark magic!')

        # ===== SPEEDSTER PERK (Player 1) =====
        if 'Speeds' in backend_perks[current_p1_perk_idx]:
            if NORMAL_SPEED1 <= SPEED_1 < 20:
                SPEED_1 = min(20, SPEED_1 + 0.05)  # tăng từ từ

        # ===== SPEEDSTER PERK (Player 2) =====
        if 'Speeds' in backend_perks[current_p2_perk_idx]:
            if NORMAL_SPEED2 <= SPEED_2 < 20:
                SPEED_2 = min(20, SPEED_2 + 0.05)
        screen.blit(BACKGROUND, (X_BG, 0))
        screen.blit(BARRIER, (0, 0))
        screen.blit(PROGRESS_BAR, (250, 0))
        display_plr()
        screen.blit(WAVE, (X_WAVE_1, 130))
        screen.blit(WAVE, (X_WAVE_2, 430))
        if LANGUAGE == 'ENGLISH':
            screen.blit(SETTING_EN, (-35, -25))
        else:
            screen.blit(SETTING_VI, (-35, -25))
        if ENERGY1_IS_VISIBLE:
            screen.blit(ENERGY_BALL, (X_POWER_1, Y_POWER_1))
        if ENERGY2_IS_VISIBLE:
            screen.blit(ENERGY_BALL, (X_POWER_2, Y_POWER_2))
        if TOGGLE_PLAYER_MARK:
            p1_highlight = YELLOW_SHIP_G.get_bounding_rect(1)
            p2_highlight = GREEN_SHIP_G.get_bounding_rect(1)
            py.draw.rect(screen, (255, 255, 0) if P1_SKIN == 'Yellow' else (0, 100, 0),
                         p1_highlight.move(0, Y_1), 2)
            py.draw.rect(screen, (0, 100, 0) if P2_SKIN == 'Green' else (255, 255, 0),
                         p2_highlight.move(0, Y_2), 2)
        check_collision()
        finish_screen_x_1 = FINISH_LINE_WORLD_X - DISTANCE_1
        finish_screen_x_2 = FINISH_LINE_WORLD_X - DISTANCE_2
        if 0 <= finish_screen_x_1 <= 900:
            screen.blit(FINISH_LINE, (finish_screen_x_1, 135))
        if 0 <= finish_screen_x_2 <= 900:
            screen.blit(FINISH_LINE, (finish_screen_x_2, 400))
        for ROCK in ROCKS:
            if 130 <= ROCK[1] <= 350:
                if not timestopping2:
                    if -1022 >= ROCK[0] > -10000:
                        ROCK[0] = -10000
                    else:
                        ROCK[0] -= SPEED_1
                if ROCK[0] < -10500:
                    while True:
                        new_y = random.randint(130, 350)
                        new_rock_rect = ROCK_IMG.get_rect(topleft=(900, new_y))
                        collision = False
                        for existing_rock in ROCKS:
                            if existing_rock is not ROCK:
                                existing_rock_rect = ROCK_IMG.get_rect(topleft=(existing_rock[0], existing_rock[1]))
                                if new_rock_rect.colliderect(existing_rock_rect):
                                    collision = True
                                    break
                        if not collision and ENERGY1_IS_VISIBLE:
                            energy1_rect = ENERGY_BALL.get_rect(topleft=(X_POWER_1, Y_POWER_1))
                            if new_rock_rect.colliderect(energy1_rect):
                                collision = True
                        if not collision:
                            ROCK[0] = 900
                            ROCK[1] = new_y
                            break
            elif 430 <= ROCK[1] <= 620:
                if not timestopping:
                    if -1022 >= ROCK[0] > -10000:
                        ROCK[0] = -10000
                    else:
                        ROCK[0] -= SPEED_2
                if ROCK[0] < -10500:
                    while True:
                        new_y = random.randint(430, 620)
                        new_rock_rect = ROCK_IMG.get_rect(topleft=(900, new_y))
                        collision = False
                        for existing_rock in ROCKS:
                            if existing_rock is not ROCK:
                                existing_rock_rect = ROCK_IMG.get_rect(topleft=(existing_rock[0], existing_rock[1]))
                                if new_rock_rect.colliderect(existing_rock_rect):
                                    collision = True
                                    break
                        if not collision and ENERGY2_IS_VISIBLE:
                            energy2_rect = ENERGY_BALL.get_rect(topleft=(X_POWER_2, Y_POWER_2))
                            if new_rock_rect.colliderect(energy2_rect):
                                collision = True
                        if not collision:
                            ROCK[0] = 900
                            ROCK[1] = new_y
                            break
            screen.blit(ROCK_IMG, (ROCK[0], ROCK[1]))
        if SPEED_DISPLAY:
            DISP_SPD1 = round(SPEED_1, 2)
            if DISP_SPD1 == int(DISP_SPD1):
                DISP_SPD1 = str(int(DISP_SPD1))  # "6"
            else:
                DISP_SPD1 = f"{DISP_SPD1:.2f}"  # "6.25"
            DISP_SPD2 = round(SPEED_2, 2)
            if DISP_SPD2 == int(DISP_SPD2):
                DISP_SPD2 = str(int(DISP_SPD2))
            else:
                DISP_SPD2 = f'{DISP_SPD2:.2f}'
            spd_render1 = font.render(f'Speed: {DISP_SPD1}' if LANGUAGE == 'ENGLISH' else f'Tốc độ: {DISP_SPD1}',
                                      True, (0, 0, 0))
            spd_render2 = font.render(f'Speed: {DISP_SPD2}' if LANGUAGE == 'ENGLISH' else f'Tốc độ: {DISP_SPD2}',
                                      True, (0, 0, 0))
            screen.blit(spd_render1, (0, Y_1 + 50))
            screen.blit(spd_render2, (0, Y_2 + 50))
        # Player 1
        if 'Flash' in backend_perks[current_p1_perk_idx]:
            perk_text1 = font.render(
                f'Uses: {flashstep_pack[0]}' if LANGUAGE == 'ENGLISH' else f'Lượt dùng: {flashstep_pack[0]}',
                True, (0, 0, 0)
            )
            screen.blit(perk_text1, (0, Y_1 - 50))

        if 'Time' in backend_perks[current_p1_perk_idx]:
            perk_text1 = font.render(
                f'Uses: {timestop_pack[0]}' if LANGUAGE == 'ENGLISH' else f'Lượt dùng: {timestop_pack[0]}',
                True, (0, 0, 0)
            )
            screen.blit(perk_text1, (0, Y_1 - 50))

        # Player 2
        if 'Flash' in backend_perks[current_p2_perk_idx]:
            perk_text2 = font.render(
                f'Uses: {flashstep_pack2[0]}' if LANGUAGE == 'ENGLISH' else f'Lượt dùng: {flashstep_pack2[0]}',
                True, (0, 0, 0)
            )
            screen.blit(perk_text2, (0, Y_2 - 50))

        if 'Time' in backend_perks[current_p2_perk_idx]:
            perk_text2 = font.render(
                f'Uses: {timestop_pack2[0]}' if LANGUAGE == 'ENGLISH' else f'Lượt dùng: {timestop_pack2[0]}',
                True, (0, 0, 0)
            )
            screen.blit(perk_text2, (0, Y_2 - 50))

        draw_energy_bars()
        screen.blit(ts_surface, (0, 0))
        display()

    # ===== END GAME =====
    elif state == 'END':
        screen.blit(BACKGROUND, (X_BG, 0))
        screen.blit(BARRIER, (0, 0))
        screen.blit(YELLOW_SHIP_G, (0, Y_1))
        screen.blit(GREEN_SHIP_G, (0, Y_2))
        screen.blit(PROGRESS_BAR, (250, 0))
        display_plr()

        screen.blit(WAVE, (X_WAVE_1, 130))
        screen.blit(WAVE, (X_WAVE_2, 430))
        for ROCK in ROCKS:
            screen.blit(ROCK_IMG, (ROCK[0], ROCK[1]))
        dark_surface = py.Surface((900, 680))
        dark_surface.fill((0, 0, 0))
        dark_surface.set_alpha(int(dark_slider.value))
        screen.blit(dark_surface, (0, 0))
        text_rect = WINNER_TEXT.get_rect()
        text_rect.centerx = screen.get_width() // 2
        text_rect.y = 200
        screen.blit(WINNER_TEXT, text_rect)
        if LANGUAGE == 'ENGLISH':
            screen.blit(REPLAY_EN, REPLAY_EN.get_rect(center=REPLAY_BOX.center))
            screen.blit(SETTING_EN, SETTING_EN.get_rect(center=BUTTONS[12].center))
        else:
            screen.blit(REPLAY_VI, REPLAY_VI.get_rect(center=REPLAY_BOX.center))
            screen.blit(SETTING_VI, SETTING_VI.get_rect(center=BUTTONS[12].center))
        if TOGGLE_FPS:
            fps_text = font.render(f"FPS: {int(clock.get_fps())}", True, (255, 255, 255))
            screen.blit(fps_text, (0, 350))
        if TOGGLE_FIREWORKS:
            update_fireworks()
        GAME_MUSIC.stop()
    py.display.update()
    clock.tick(120)
"""
CODE GIÚP THAY ĐỔI TỐC ĐỘ CỦA NGƯỜI KHI CHẠM VÀO ĐÁ:
def check_collision():
    global SPEED_1, SPEED_2
    global X_POWER_1, X_POWER_2, Y_POWER_1, Y_POWER_2
    global ENERGY1_IS_VISIBLE, ENERGY2_IS_VISIBLE, ENERGY_TIMER_1, ENERGY_TIMER_2
    global ENERGY_PLAYER1, ENERGY_PLAYER2
    global flashstepping, flashstepping2
    global timestopping, timestopping2
    global absorption_pack, absorption_pack2
    P1_HITBOX = YELLOW_SHIP_G.get_rect(topleft=(0, Y_1))
    P2_HITBOX = GREEN_SHIP_G.get_rect(topleft=(0, Y_2))
    backend_perks = pk.get_perks('ENGLISH')
    for ROCK in ROCKS:
        ROCK_COLLIDE_BOX = ROCK_IMG.get_rect(topleft=(ROCK[0], ROCK[1]))
        if P1_HITBOX.colliderect(ROCK_COLLIDE_BOX) and (not timestopping and not flashstepping):
            ROCK[0] = -10000
            if TOGGLE_SFX:
                ROCK_SOUND.play(0)
            if 'Speeds' in backend_perks[current_p1_perk_idx]:
                SPEED_1 = -5
            elif backend_perks[current_p1_perk_idx] == 'Reduce Slowness':
                SPEED_1 = max(0.1, SPEED_1 - (4 * .1))
            elif backend_perks[current_p1_perk_idx] == 'Rage':
                ENERGY_PLAYER1 += 8
                SPEED_1 = max(0.1, SPEED_1 - 3)
            elif 'Absorption' in backend_perks[current_p1_perk_idx]:
                if absorption_pack[0] > 0:
                    absorption_pack[0] = max(0, absorption_pack[0] - 1)
                    SPEED_1 = max(40, SPEED_1 + 3)
                    print(f'{absorption_pack[0]} charges left')
                else:  # Out of charges
                    SPEED_1 = max(0.1, SPEED_1 - 4)
            else:
                SPEED_1 = max(0.1, SPEED_1 - 4)
        if P2_HITBOX.colliderect(ROCK_COLLIDE_BOX) and (not timestopping2 and not flashstepping2):
            ROCK[0] = -10000
            if TOGGLE_SFX:
                ROCK_SOUND.play(0)
            if 'Speeds' in backend_perks[current_p2_perk_idx]:
                SPEED_2 = -5
            elif backend_perks[current_p2_perk_idx] == 'Reduce Slowness':
                SPEED_2 = max(0.1, SPEED_2 - (4 * .1))
            elif 'Absorption' in backend_perks[current_p2_perk_idx]:
                if absorption_pack2[0] > 0:
                    absorption_pack2[0] = max(0, absorption_pack2[0] - 1)
                    SPEED_2 = max(35, SPEED_2 + 3)
                    print(f'{absorption_pack2[0]} charges left')
                else:  # Out of charges
                    SPEED_2 = max(0.1, SPEED_1 - 4)
            else:
                if backend_perks[current_p2_perk_idx] == 'Rage':
                    ENERGY_PLAYER2 += 8
                SPEED_2 = max(0.1, SPEED_2 - 4)
    if ENERGY1_IS_VISIBLE:
        BALL_COLLISION_1 = ENERGY_BALL.get_rect(topleft=(X_POWER_1, Y_POWER_1))
        if P1_HITBOX.colliderect(BALL_COLLISION_1):
            SPEED_1 += 3  # Increase 3 speed for player 1
            ENERGY1_IS_VISIBLE = False
            ENERGY_TIMER_1 = py.time.get_ticks()
            if TOGGLE_SFX:
                ENERGY_BALL_SOUND.play(0)
    if ENERGY2_IS_VISIBLE:
        BALL_COLLISION_2 = ENERGY_BALL.get_rect(topleft=(X_POWER_2, Y_POWER_2))
        if P2_HITBOX.colliderect(BALL_COLLISION_2):
            SPEED_2 += 3  # Increase 3 speed for player 2
            ENERGY2_IS_VISIBLE = False
            ENERGY_TIMER_2 = py.time.get_ticks()
            if TOGGLE_SFX:
                ENERGY_BALL_SOUND.play(0)

"""
